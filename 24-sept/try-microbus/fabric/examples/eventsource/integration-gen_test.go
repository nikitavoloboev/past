/*
Copyright (c) 2023-2024 Microbus LLC and various contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Microbus. DO NOT EDIT.

package eventsource

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/andybalholm/cascadia"
	"github.com/microbus-io/fabric/application"
	"github.com/microbus-io/fabric/connector"
	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/frame"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/rand"
	"github.com/microbus-io/fabric/utils"
	"github.com/microbus-io/testarossa"
	"golang.org/x/net/html"

	"github.com/microbus-io/fabric/examples/eventsource/eventsourceapi"
)

var (
	_ bytes.Buffer
	_ context.Context
	_ fmt.Stringer
	_ io.Reader
	_ *http.Request
	_ os.File
	_ time.Time
	_ strings.Builder
	_ cascadia.Sel
	_ *connector.Connector
	_ *errors.TracedError
	_ frame.Frame
	_ *httpx.BodyReader
	_ pub.Option
	_ rand.Void
	_ utils.SyncMap[string, string]
	_ testarossa.TestingT
	_ *html.Node
	_ *eventsourceapi.Client
)

var (
	// App manages the lifecycle of the microservices used in the test
	App *application.Application
	// Svc is the eventsource.example microservice being tested
	Svc *Service
)

func TestMain(m *testing.M) {
	var code int

	// Initialize the application
	err := func() error {
		var err error
		App = application.NewTesting()
		Svc = NewService()
		err = Initialize()
		if err != nil {
			return err
		}
		err = App.Startup()
		if err != nil {
			return err
		}
		return nil
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
		code = 19
	}

	// Run the tests
	if err == nil {
		code = m.Run()
	}

	// Terminate the app
	err = func() error {
		var err error
		var lastErr error
		err = App.Shutdown()
		if err != nil {
			lastErr = err
		}
		err = Terminate()
		if err != nil {
			lastErr = err
		}
		return lastErr
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
	}

	os.Exit(code)
}

// Context creates a new context for a test.
func Context() context.Context {
	return frame.ContextWithFrame(context.Background())
}

// RegisterTestCase assists in asserting against the results of executing Register.
type RegisterTestCase struct {
	_t *testing.T
	_dur time.Duration
	allowed bool
	err error
}

// Expect asserts no error and exact return values.
func (_tc *RegisterTestCase) Expect(allowed bool) *RegisterTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, allowed, _tc.allowed)
	}
	return _tc
}

// Error asserts an error.
func (tc *RegisterTestCase) Error(errContains string) *RegisterTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *RegisterTestCase) ErrorCode(statusCode int) *RegisterTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *RegisterTestCase) NoError() *RegisterTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *RegisterTestCase) CompletedIn(threshold time.Duration) *RegisterTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *RegisterTestCase) Assert(asserter func(t *testing.T, allowed bool, err error)) *RegisterTestCase {
	asserter(tc._t, tc.allowed, tc.err)
	return tc
}

// Get returns the result of executing Register.
func (tc *RegisterTestCase) Get() (allowed bool, err error) {
	return tc.allowed, tc.err
}

// Register executes the function and returns a corresponding test case.
func Register(t *testing.T, ctx context.Context, email string) *RegisterTestCase {
	tc := &RegisterTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.allowed, tc.err = Svc.Register(ctx, email)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// OnAllowRegisterTestCase assists in asserting the sink of OnAllowRegister.
type OnAllowRegisterTestCase struct {
	_t *testing.T
    _asserters []func()
	_done chan bool
	_triggered bool
	ctx context.Context
	email string
	allow bool
	err error
}

// Expect asserts that the event sink was triggered with an exact match of its input arguments.
func (_tc *OnAllowRegisterTestCase) Expect(email string) *OnAllowRegisterTestCase {
	_tc._asserters = append(_tc._asserters, func() {
		if testarossa.True(_tc._t, _tc._triggered, "Event sink was not triggered") {
			testarossa.Equal(_tc._t, email, _tc.email)
		}
	})
	return _tc
}

// Assert asserts that the event sink was triggered with a custom function to assert its input arguments.
func (_tc *OnAllowRegisterTestCase) Assert(asserter func(t *testing.T, ctx context.Context, email string)) *OnAllowRegisterTestCase {
	_tc._asserters = append(_tc._asserters, func() {
		if testarossa.True(_tc._t, _tc._triggered, "Event sink was not triggered") {
			asserter(_tc._t, _tc.ctx, _tc.email)
		}
	})
	return _tc
}

// Return sets the values to return from the event sink to the event source.
func (_tc *OnAllowRegisterTestCase) Return(allow bool, err error) *OnAllowRegisterTestCase {
	_tc.allow = allow
	_tc.err = err
	return _tc
}

// Wait waits for the event sink to be triggered. It is necessary to wait for events that are triggered asynchronously.
func (_tc *OnAllowRegisterTestCase) Wait() *OnAllowRegisterTestCase {
	timeout := 20 * time.Second
	if deadline, ok := _tc._t.Deadline(); ok {
		timeout = time.Until(deadline)
	}
	timer := time.NewTimer(timeout)
	defer timer.Stop()
	select {
	case <-_tc._done:
	case <-timer.C:
		testarossa.True(_tc._t, false, "Timed out", "Event sink was not triggered")
	}
	return _tc
}

// OnAllowRegister creates a run-once event sink and returns the corresponding test case.
func OnAllowRegister(t *testing.T) *OnAllowRegisterTestCase {
	_tc := &OnAllowRegisterTestCase{
		_t: t,
		_done: make(chan bool),
	}
	con := connector.New("OnAllowRegister." + rand.AlphaNum64(12))
	eventsourceapi.NewHook(con).OnAllowRegister(func(ctx context.Context, email string) (allow bool, err error) {
		eventsourceapi.NewHook(con).OnAllowRegister(nil)
		_tc.ctx = ctx
		_tc.email = email
		_tc._triggered = true
		close(_tc._done)
		for _, asserter := range _tc._asserters {
			asserter()
		}
		_tc._asserters = nil
		return _tc.allow, _tc.err
	})
	App.AddAndStartup(con)
	_tc._t.Cleanup(func() {
		con.Shutdown()
		App.Remove(con)
		for _, asserter := range _tc._asserters {
			asserter()
		}
	})
	return _tc
}

// OnRegisteredTestCase assists in asserting the sink of OnRegistered.
type OnRegisteredTestCase struct {
	_t *testing.T
    _asserters []func()
	_done chan bool
	_triggered bool
	ctx context.Context
	email string
	err error
}

// Expect asserts that the event sink was triggered with an exact match of its input arguments.
func (_tc *OnRegisteredTestCase) Expect(email string) *OnRegisteredTestCase {
	_tc._asserters = append(_tc._asserters, func() {
		if testarossa.True(_tc._t, _tc._triggered, "Event sink was not triggered") {
			testarossa.Equal(_tc._t, email, _tc.email)
		}
	})
	return _tc
}

// Assert asserts that the event sink was triggered with a custom function to assert its input arguments.
func (_tc *OnRegisteredTestCase) Assert(asserter func(t *testing.T, ctx context.Context, email string)) *OnRegisteredTestCase {
	_tc._asserters = append(_tc._asserters, func() {
		if testarossa.True(_tc._t, _tc._triggered, "Event sink was not triggered") {
			asserter(_tc._t, _tc.ctx, _tc.email)
		}
	})
	return _tc
}

// Return sets the values to return from the event sink to the event source.
func (_tc *OnRegisteredTestCase) Return(err error) *OnRegisteredTestCase {
	_tc.err = err
	return _tc
}

// Wait waits for the event sink to be triggered. It is necessary to wait for events that are triggered asynchronously.
func (_tc *OnRegisteredTestCase) Wait() *OnRegisteredTestCase {
	timeout := 20 * time.Second
	if deadline, ok := _tc._t.Deadline(); ok {
		timeout = time.Until(deadline)
	}
	timer := time.NewTimer(timeout)
	defer timer.Stop()
	select {
	case <-_tc._done:
	case <-timer.C:
		testarossa.True(_tc._t, false, "Timed out", "Event sink was not triggered")
	}
	return _tc
}

// OnRegistered creates a run-once event sink and returns the corresponding test case.
func OnRegistered(t *testing.T) *OnRegisteredTestCase {
	_tc := &OnRegisteredTestCase{
		_t: t,
		_done: make(chan bool),
	}
	con := connector.New("OnRegistered." + rand.AlphaNum64(12))
	eventsourceapi.NewHook(con).OnRegistered(func(ctx context.Context, email string) (err error) {
		eventsourceapi.NewHook(con).OnRegistered(nil)
		_tc.ctx = ctx
		_tc.email = email
		_tc._triggered = true
		close(_tc._done)
		for _, asserter := range _tc._asserters {
			asserter()
		}
		_tc._asserters = nil
		return _tc.err
	})
	App.AddAndStartup(con)
	_tc._t.Cleanup(func() {
		con.Shutdown()
		App.Remove(con)
		for _, asserter := range _tc._asserters {
			asserter()
		}
	})
	return _tc
}
