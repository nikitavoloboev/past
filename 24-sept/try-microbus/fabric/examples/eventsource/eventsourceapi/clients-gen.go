/*
Copyright (c) 2023-2024 Microbus LLC and various contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Microbus. DO NOT EDIT.

/*
Package eventsourceapi implements the public API of the eventsource.example microservice,
including clients and data structures.

The event source microservice fires events that are caught by the event sink microservice.
*/
package eventsourceapi

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/service"
	"github.com/microbus-io/fabric/sub"
)

var (
	_ context.Context
	_ *json.Decoder
	_ io.Reader
	_ *http.Request
	_ *url.URL
	_ strings.Reader
	_ time.Duration
	_ *errors.TracedError
	_ *httpx.BodyReader
	_ pub.Option
	_ sub.Option
)

// Hostname is the default hostname of the microservice: eventsource.example.
const Hostname = "eventsource.example"

// Fully-qualified URLs of the microservice's endpoints.
var (
	URLOfRegister = httpx.JoinHostAndPath(Hostname, `:443/register`)
)

// Client is an interface to calling the endpoints of the eventsource.example microservice.
// This simple version is for unicast calls.
type Client struct {
	svc  service.Publisher
	host string
}

// NewClient creates a new unicast client to the eventsource.example microservice.
func NewClient(caller service.Publisher) *Client {
	return &Client{
		svc:  caller,
		host: "eventsource.example",
	}
}

// ForHost replaces the default hostname of this client.
func (_c *Client) ForHost(host string) *Client {
	_c.host = host
	return _c
}

// MulticastClient is an interface to calling the endpoints of the eventsource.example microservice.
// This advanced version is for multicast calls.
type MulticastClient struct {
	svc  service.Publisher
	host string
}

// NewMulticastClient creates a new multicast client to the eventsource.example microservice.
func NewMulticastClient(caller service.Publisher) *MulticastClient {
	return &MulticastClient{
		svc:  caller,
		host: "eventsource.example",
	}
}

// ForHost replaces the default hostname of this client.
func (_c *MulticastClient) ForHost(host string) *MulticastClient {
	_c.host = host
	return _c
}

// MulticastTrigger is an interface to trigger the events of the eventsource.example microservice.
type MulticastTrigger struct {
	svc  service.Publisher
	host string
}

// NewMulticastTrigger creates a new multicast trigger of the eventsource.example microservice.
func NewMulticastTrigger(caller service.Publisher) *MulticastTrigger {
	return &MulticastTrigger{
		svc:  caller,
		host: "eventsource.example",
	}
}

// ForHost replaces the default hostname of this trigger.
func (_c *MulticastTrigger) ForHost(host string) *MulticastTrigger {
	_c.host = host
	return _c
}

// Hook assists in the subscription to the events of the eventsource.example microservice.
type Hook struct {
	svc  service.Subscriber
	host string
}

// NewHook creates a new hook to the events of the eventsource.example microservice.
func NewHook(listener service.Subscriber) *Hook {
	return &Hook{
		svc:  listener,
		host: "eventsource.example",
	}
}

// ForHost replaces the default hostname of this hook.
func (_c *Hook) ForHost(host string) *Hook {
	_c.host = host
	return _c
}

// RegisterIn are the input arguments of Register.
type RegisterIn struct {
	Email string `json:"email"`
}

// RegisterOut are the return values of Register.
type RegisterOut struct {
	Allowed bool `json:"allowed"`
}

// RegisterResponse is the response to Register.
type RegisterResponse struct {
	data RegisterOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *RegisterResponse) Get() (allowed bool, err error) {
	allowed = _out.data.Allowed
	err = _out.err
	return
}

/*
Register attempts to register a new user.
*/
func (_c *MulticastClient) Register(ctx context.Context, email string) <-chan *RegisterResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/register`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`email`: email,
	})
	_in := RegisterIn{
		email,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *RegisterResponse, cap(_ch))
	for _i := range _ch {
		var _r RegisterResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
Register attempts to register a new user.
*/
func (_c *Client) Register(ctx context.Context, email string) (allowed bool, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/register`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`email`: email,
	})
	_in := RegisterIn{
		email,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out RegisterOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	allowed = _out.Allowed
	return
}

// OnAllowRegisterIn are the input arguments of OnAllowRegister.
type OnAllowRegisterIn struct {
	Email string `json:"email"`
}

// OnAllowRegisterOut are the return values of OnAllowRegister.
type OnAllowRegisterOut struct {
	Allow bool `json:"allow"`
}

// OnAllowRegisterResponse is the response to OnAllowRegister.
type OnAllowRegisterResponse struct {
	data OnAllowRegisterOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *OnAllowRegisterResponse) Get() (allow bool, err error) {
	allow = _out.data.Allow
	err = _out.err
	return
}

/*
OnAllowRegister is called before a user is allowed to register.
Event sinks are given the opportunity to block the registration.
*/
func (_c *MulticastTrigger) OnAllowRegister(ctx context.Context, email string) <-chan *OnAllowRegisterResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:417/on-allow-register`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`email`: email,
	})
	_in := OnAllowRegisterIn{
		email,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *OnAllowRegisterResponse, cap(_ch))
	for _i := range _ch {
		var _r OnAllowRegisterResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
OnAllowRegister is called before a user is allowed to register.
Event sinks are given the opportunity to block the registration.
*/
func (_c *Hook) OnAllowRegister(handler func(ctx context.Context, email string) (allow bool, err error)) error {
	doOnAllowRegister := func(w http.ResponseWriter, r *http.Request) error {
		var i OnAllowRegisterIn
		var o OnAllowRegisterOut
		err := httpx.ParseRequestData(r, &i)
		if err != nil {
			return errors.Trace(err)
		}
		o.Allow, err = handler(
			r.Context(),
			i.Email,
		)
		if err != nil {
			return err // No trace
		}
		w.Header().Set("Content-Type", "application/json")
		encoder := json.NewEncoder(w)
		err = encoder.Encode(o)
		if err != nil {
			return errors.Trace(err)
		}
		return nil
	}
	path := httpx.JoinHostAndPath(_c.host, `:417/on-allow-register`)
	if handler == nil {
		return _c.svc.Unsubscribe(`POST`, path)
	}
	return _c.svc.Subscribe(`POST`, path, doOnAllowRegister)
}

// OnRegisteredIn are the input arguments of OnRegistered.
type OnRegisteredIn struct {
	Email string `json:"email"`
}

// OnRegisteredOut are the return values of OnRegistered.
type OnRegisteredOut struct {
}

// OnRegisteredResponse is the response to OnRegistered.
type OnRegisteredResponse struct {
	data OnRegisteredOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *OnRegisteredResponse) Get() (err error) {
	err = _out.err
	return
}

/*
OnRegistered is called when a user is successfully registered.
*/
func (_c *MulticastTrigger) OnRegistered(ctx context.Context, email string) <-chan *OnRegisteredResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:417/on-registered`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`email`: email,
	})
	_in := OnRegisteredIn{
		email,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *OnRegisteredResponse, cap(_ch))
	for _i := range _ch {
		var _r OnRegisteredResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
OnRegistered is called when a user is successfully registered.
*/
func (_c *Hook) OnRegistered(handler func(ctx context.Context, email string) (err error)) error {
	doOnRegistered := func(w http.ResponseWriter, r *http.Request) error {
		var i OnRegisteredIn
		var o OnRegisteredOut
		err := httpx.ParseRequestData(r, &i)
		if err != nil {
			return errors.Trace(err)
		}
		err = handler(
			r.Context(),
			i.Email,
		)
		if err != nil {
			return err // No trace
		}
		w.Header().Set("Content-Type", "application/json")
		encoder := json.NewEncoder(w)
		err = encoder.Encode(o)
		if err != nil {
			return errors.Trace(err)
		}
		return nil
	}
	path := httpx.JoinHostAndPath(_c.host, `:417/on-registered`)
	if handler == nil {
		return _c.svc.Unsubscribe(`POST`, path)
	}
	return _c.svc.Subscribe(`POST`, path, doOnRegistered)
}
