/*
Copyright (c) 2023-2024 Microbus LLC and various contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Microbus. DO NOT EDIT.

package hello

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/andybalholm/cascadia"
	"github.com/microbus-io/fabric/application"
	"github.com/microbus-io/fabric/connector"
	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/frame"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/rand"
	"github.com/microbus-io/fabric/utils"
	"github.com/microbus-io/testarossa"
	"golang.org/x/net/html"

	"github.com/microbus-io/fabric/examples/hello/helloapi"
)

var (
	_ bytes.Buffer
	_ context.Context
	_ fmt.Stringer
	_ io.Reader
	_ *http.Request
	_ os.File
	_ time.Time
	_ strings.Builder
	_ cascadia.Sel
	_ *connector.Connector
	_ *errors.TracedError
	_ frame.Frame
	_ *httpx.BodyReader
	_ pub.Option
	_ rand.Void
	_ utils.SyncMap[string, string]
	_ testarossa.TestingT
	_ *html.Node
	_ *helloapi.Client
)

var (
	// App manages the lifecycle of the microservices used in the test
	App *application.Application
	// Svc is the hello.example microservice being tested
	Svc *Service
)

func TestMain(m *testing.M) {
	var code int

	// Initialize the application
	err := func() error {
		var err error
		App = application.NewTesting()
		Svc = NewService()
		err = Initialize()
		if err != nil {
			return err
		}
		err = App.Startup()
		if err != nil {
			return err
		}
		return nil
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
		code = 19
	}

	// Run the tests
	if err == nil {
		code = m.Run()
	}

	// Terminate the app
	err = func() error {
		var err error
		var lastErr error
		err = App.Shutdown()
		if err != nil {
			lastErr = err
		}
		err = Terminate()
		if err != nil {
			lastErr = err
		}
		return lastErr
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
	}

	os.Exit(code)
}

// Context creates a new context for a test.
func Context() context.Context {
	return frame.ContextWithFrame(context.Background())
}

// HelloTestCase assists in asserting against the results of executing Hello.
type HelloTestCase struct {
	t *testing.T
	dur time.Duration
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *HelloTestCase) StatusOK() *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *HelloTestCase) StatusCode(statusCode int) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response body contains the string or byte array value.
func (tc *HelloTestCase) BodyContains(value any) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.True(tc.t, bytes.Contains(body, v), "%v does not contain %v", body, v)
		case string:
			testarossa.Contains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.Contains(tc.t, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response body does not contain the string or byte array value.
func (tc *HelloTestCase) BodyNotContains(value any) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.False(tc.t, bytes.Contains(body, v), "%v contains %v", body, v)
		case string:
			testarossa.NotContains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.NotContains(tc.t, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains the value.
func (tc *HelloTestCase) HeaderContains(headerName string, value string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *HelloTestCase) HeaderNotContains(headerName string, value string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotContains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderEqual asserts no error and that the named header matches the value.
func (tc *HelloTestCase) HeaderEqual(headerName string, value string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderNotEqual asserts no error and that the named header does not matche the value.
func (tc *HelloTestCase) HeaderNotEqual(headerName string, value string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *HelloTestCase) HeaderExists(headerName string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s does not exist", headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header does not exists.
func (tc *HelloTestCase) HeaderNotExists(headerName string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s exists", headerName)
	}
	return tc
}

// ContentType asserts no error and that the Content-Type header matches the expected value.
func (tc *HelloTestCase) ContentType(expected string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, expected, tc.res.Header.Get("Content-Type"))
	}
	return tc
}

/*
TagExists asserts no error and that the at least one tag matches the CSS selector query.

Examples:

	TagExists(`TR > TD > A.expandable[href]`)
	TagExists(`DIV#main_panel`)
	TagExists(`TR TD INPUT[name="x"]`)
*/
func (tc *HelloTestCase) TagExists(cssSelectorQuery string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.NotEqual(tc.t, 0, len(matches), "Found no tags matching %s", cssSelectorQuery)
	}
	return tc
}

/*
TagNotExists asserts no error and that the no tag matches the CSS selector query.

Example:

	TagNotExists(`TR > TD > A.expandable[href]`)
	TagNotExists(`DIV#main_panel`)
	TagNotExists(`TR TD INPUT[name="x"]`)
*/
func (tc *HelloTestCase) TagNotExists(cssSelectorQuery string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.Equal(tc.t, 0, len(matches), "Found %d tag(s) matching %s", len(matches), cssSelectorQuery)
	}
	return tc
}

/*
TagEqual asserts no error and that the at least one of the tags matching the CSS selector query
either contains the exact text itself or has a descendant that does.

Example:

	TagEqual("TR > TD > A.expandable[href]", "Expand")
	TagEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *HelloTestCase) TagEqual(cssSelectorQuery string, value string) *HelloTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagContains asserts no error and that the at least one of the tags matching the CSS selector query
either contains the text itself or has a descendant that does.

Example:

	TagContains("TR > TD > A.expandable[href]", "Expand")
	TagContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *HelloTestCase) TagContains(cssSelectorQuery string, value string) *HelloTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotEqual asserts no error and that there is no tag matching the CSS selector that
either contains the exact text itself or has a descendant that does.

Example:

	TagNotEqual("TR > TD > A[href]", "Harry Potter")
	TagNotEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *HelloTestCase) TagNotEqual(cssSelectorQuery string, value string) *HelloTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotContains asserts no error and that there is no tag matching the CSS selector that
either contains the text itself or has a descendant that does.

Example:

	TagNotContains("TR > TD > A[href]", "Harry Potter")
	TagNotContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *HelloTestCase) TagNotContains(cssSelectorQuery string, value string) *HelloTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

// Error asserts an error.
func (tc *HelloTestCase) Error(errContains string) *HelloTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *HelloTestCase) ErrorCode(statusCode int) *HelloTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *HelloTestCase) NoError() *HelloTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *HelloTestCase) CompletedIn(threshold time.Duration) *HelloTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *HelloTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *HelloTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Hello.
func (tc *HelloTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
Hello_Get performs a GET request to the Hello endpoint.

Hello prints a greeting.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Hello_Get(t *testing.T, ctx context.Context, url string) *HelloTestCase {
	tc := &HelloTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfHello, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest("GET", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Hello(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Hello_Post performs a POST request to the Hello endpoint.

Hello prints a greeting.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func Hello_Post(t *testing.T, ctx context.Context, url string, contentType string, body any) *HelloTestCase {
	tc := &HelloTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfHello, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest("POST", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	err = httpx.SetRequestBody(r, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Hello(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Hello prints a greeting.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Hello(t *testing.T, r *http.Request) *HelloTestCase {
	tc := &HelloTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	url, err := httpx.ResolveURL(helloapi.URLOfHello, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = httpx.ParseURL(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	for k, vv := range frame.Of(r.Context()).Header() {
		r.Header[k] = vv
	}
	ctx := frame.ContextWithFrameOf(r.Context(), r.Header)
	r = r.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Hello(w, r)
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// EchoTestCase assists in asserting against the results of executing Echo.
type EchoTestCase struct {
	t *testing.T
	dur time.Duration
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *EchoTestCase) StatusOK() *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *EchoTestCase) StatusCode(statusCode int) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response body contains the string or byte array value.
func (tc *EchoTestCase) BodyContains(value any) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.True(tc.t, bytes.Contains(body, v), "%v does not contain %v", body, v)
		case string:
			testarossa.Contains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.Contains(tc.t, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response body does not contain the string or byte array value.
func (tc *EchoTestCase) BodyNotContains(value any) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.False(tc.t, bytes.Contains(body, v), "%v contains %v", body, v)
		case string:
			testarossa.NotContains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.NotContains(tc.t, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains the value.
func (tc *EchoTestCase) HeaderContains(headerName string, value string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *EchoTestCase) HeaderNotContains(headerName string, value string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotContains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderEqual asserts no error and that the named header matches the value.
func (tc *EchoTestCase) HeaderEqual(headerName string, value string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderNotEqual asserts no error and that the named header does not matche the value.
func (tc *EchoTestCase) HeaderNotEqual(headerName string, value string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *EchoTestCase) HeaderExists(headerName string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s does not exist", headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header does not exists.
func (tc *EchoTestCase) HeaderNotExists(headerName string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s exists", headerName)
	}
	return tc
}

// ContentType asserts no error and that the Content-Type header matches the expected value.
func (tc *EchoTestCase) ContentType(expected string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, expected, tc.res.Header.Get("Content-Type"))
	}
	return tc
}

/*
TagExists asserts no error and that the at least one tag matches the CSS selector query.

Examples:

	TagExists(`TR > TD > A.expandable[href]`)
	TagExists(`DIV#main_panel`)
	TagExists(`TR TD INPUT[name="x"]`)
*/
func (tc *EchoTestCase) TagExists(cssSelectorQuery string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.NotEqual(tc.t, 0, len(matches), "Found no tags matching %s", cssSelectorQuery)
	}
	return tc
}

/*
TagNotExists asserts no error and that the no tag matches the CSS selector query.

Example:

	TagNotExists(`TR > TD > A.expandable[href]`)
	TagNotExists(`DIV#main_panel`)
	TagNotExists(`TR TD INPUT[name="x"]`)
*/
func (tc *EchoTestCase) TagNotExists(cssSelectorQuery string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.Equal(tc.t, 0, len(matches), "Found %d tag(s) matching %s", len(matches), cssSelectorQuery)
	}
	return tc
}

/*
TagEqual asserts no error and that the at least one of the tags matching the CSS selector query
either contains the exact text itself or has a descendant that does.

Example:

	TagEqual("TR > TD > A.expandable[href]", "Expand")
	TagEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *EchoTestCase) TagEqual(cssSelectorQuery string, value string) *EchoTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagContains asserts no error and that the at least one of the tags matching the CSS selector query
either contains the text itself or has a descendant that does.

Example:

	TagContains("TR > TD > A.expandable[href]", "Expand")
	TagContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *EchoTestCase) TagContains(cssSelectorQuery string, value string) *EchoTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotEqual asserts no error and that there is no tag matching the CSS selector that
either contains the exact text itself or has a descendant that does.

Example:

	TagNotEqual("TR > TD > A[href]", "Harry Potter")
	TagNotEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *EchoTestCase) TagNotEqual(cssSelectorQuery string, value string) *EchoTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotContains asserts no error and that there is no tag matching the CSS selector that
either contains the text itself or has a descendant that does.

Example:

	TagNotContains("TR > TD > A[href]", "Harry Potter")
	TagNotContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *EchoTestCase) TagNotContains(cssSelectorQuery string, value string) *EchoTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

// Error asserts an error.
func (tc *EchoTestCase) Error(errContains string) *EchoTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *EchoTestCase) ErrorCode(statusCode int) *EchoTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *EchoTestCase) NoError() *EchoTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *EchoTestCase) CompletedIn(threshold time.Duration) *EchoTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *EchoTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *EchoTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Echo.
func (tc *EchoTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
Echo_Get performs a GET request to the Echo endpoint.

Echo back the incoming request in wire format.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Echo_Get(t *testing.T, ctx context.Context, url string) *EchoTestCase {
	tc := &EchoTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfEcho, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest("GET", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Echo(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Echo_Post performs a POST request to the Echo endpoint.

Echo back the incoming request in wire format.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func Echo_Post(t *testing.T, ctx context.Context, url string, contentType string, body any) *EchoTestCase {
	tc := &EchoTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfEcho, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest("POST", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	err = httpx.SetRequestBody(r, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Echo(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Echo back the incoming request in wire format.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Echo(t *testing.T, r *http.Request) *EchoTestCase {
	tc := &EchoTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	url, err := httpx.ResolveURL(helloapi.URLOfEcho, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = httpx.ParseURL(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	for k, vv := range frame.Of(r.Context()).Header() {
		r.Header[k] = vv
	}
	ctx := frame.ContextWithFrameOf(r.Context(), r.Header)
	r = r.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Echo(w, r)
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// PingTestCase assists in asserting against the results of executing Ping.
type PingTestCase struct {
	t *testing.T
	dur time.Duration
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *PingTestCase) StatusOK() *PingTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *PingTestCase) StatusCode(statusCode int) *PingTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response body contains the string or byte array value.
func (tc *PingTestCase) BodyContains(value any) *PingTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.True(tc.t, bytes.Contains(body, v), "%v does not contain %v", body, v)
		case string:
			testarossa.Contains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.Contains(tc.t, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response body does not contain the string or byte array value.
func (tc *PingTestCase) BodyNotContains(value any) *PingTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.False(tc.t, bytes.Contains(body, v), "%v contains %v", body, v)
		case string:
			testarossa.NotContains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.NotContains(tc.t, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains the value.
func (tc *PingTestCase) HeaderContains(headerName string, value string) *PingTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *PingTestCase) HeaderNotContains(headerName string, value string) *PingTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotContains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderEqual asserts no error and that the named header matches the value.
func (tc *PingTestCase) HeaderEqual(headerName string, value string) *PingTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderNotEqual asserts no error and that the named header does not matche the value.
func (tc *PingTestCase) HeaderNotEqual(headerName string, value string) *PingTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *PingTestCase) HeaderExists(headerName string) *PingTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s does not exist", headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header does not exists.
func (tc *PingTestCase) HeaderNotExists(headerName string) *PingTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s exists", headerName)
	}
	return tc
}

// ContentType asserts no error and that the Content-Type header matches the expected value.
func (tc *PingTestCase) ContentType(expected string) *PingTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, expected, tc.res.Header.Get("Content-Type"))
	}
	return tc
}

/*
TagExists asserts no error and that the at least one tag matches the CSS selector query.

Examples:

	TagExists(`TR > TD > A.expandable[href]`)
	TagExists(`DIV#main_panel`)
	TagExists(`TR TD INPUT[name="x"]`)
*/
func (tc *PingTestCase) TagExists(cssSelectorQuery string) *PingTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.NotEqual(tc.t, 0, len(matches), "Found no tags matching %s", cssSelectorQuery)
	}
	return tc
}

/*
TagNotExists asserts no error and that the no tag matches the CSS selector query.

Example:

	TagNotExists(`TR > TD > A.expandable[href]`)
	TagNotExists(`DIV#main_panel`)
	TagNotExists(`TR TD INPUT[name="x"]`)
*/
func (tc *PingTestCase) TagNotExists(cssSelectorQuery string) *PingTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.Equal(tc.t, 0, len(matches), "Found %d tag(s) matching %s", len(matches), cssSelectorQuery)
	}
	return tc
}

/*
TagEqual asserts no error and that the at least one of the tags matching the CSS selector query
either contains the exact text itself or has a descendant that does.

Example:

	TagEqual("TR > TD > A.expandable[href]", "Expand")
	TagEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *PingTestCase) TagEqual(cssSelectorQuery string, value string) *PingTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagContains asserts no error and that the at least one of the tags matching the CSS selector query
either contains the text itself or has a descendant that does.

Example:

	TagContains("TR > TD > A.expandable[href]", "Expand")
	TagContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *PingTestCase) TagContains(cssSelectorQuery string, value string) *PingTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotEqual asserts no error and that there is no tag matching the CSS selector that
either contains the exact text itself or has a descendant that does.

Example:

	TagNotEqual("TR > TD > A[href]", "Harry Potter")
	TagNotEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *PingTestCase) TagNotEqual(cssSelectorQuery string, value string) *PingTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotContains asserts no error and that there is no tag matching the CSS selector that
either contains the text itself or has a descendant that does.

Example:

	TagNotContains("TR > TD > A[href]", "Harry Potter")
	TagNotContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *PingTestCase) TagNotContains(cssSelectorQuery string, value string) *PingTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

// Error asserts an error.
func (tc *PingTestCase) Error(errContains string) *PingTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *PingTestCase) ErrorCode(statusCode int) *PingTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *PingTestCase) NoError() *PingTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *PingTestCase) CompletedIn(threshold time.Duration) *PingTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *PingTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *PingTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Ping.
func (tc *PingTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
Ping_Get performs a GET request to the Ping endpoint.

Ping all microservices and list them.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Ping_Get(t *testing.T, ctx context.Context, url string) *PingTestCase {
	tc := &PingTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfPing, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest("GET", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Ping(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Ping_Post performs a POST request to the Ping endpoint.

Ping all microservices and list them.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func Ping_Post(t *testing.T, ctx context.Context, url string, contentType string, body any) *PingTestCase {
	tc := &PingTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfPing, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest("POST", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	err = httpx.SetRequestBody(r, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Ping(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Ping all microservices and list them.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Ping(t *testing.T, r *http.Request) *PingTestCase {
	tc := &PingTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	url, err := httpx.ResolveURL(helloapi.URLOfPing, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = httpx.ParseURL(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	for k, vv := range frame.Of(r.Context()).Header() {
		r.Header[k] = vv
	}
	ctx := frame.ContextWithFrameOf(r.Context(), r.Header)
	r = r.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Ping(w, r)
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// CalculatorTestCase assists in asserting against the results of executing Calculator.
type CalculatorTestCase struct {
	t *testing.T
	dur time.Duration
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *CalculatorTestCase) StatusOK() *CalculatorTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *CalculatorTestCase) StatusCode(statusCode int) *CalculatorTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response body contains the string or byte array value.
func (tc *CalculatorTestCase) BodyContains(value any) *CalculatorTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.True(tc.t, bytes.Contains(body, v), "%v does not contain %v", body, v)
		case string:
			testarossa.Contains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.Contains(tc.t, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response body does not contain the string or byte array value.
func (tc *CalculatorTestCase) BodyNotContains(value any) *CalculatorTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.False(tc.t, bytes.Contains(body, v), "%v contains %v", body, v)
		case string:
			testarossa.NotContains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.NotContains(tc.t, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains the value.
func (tc *CalculatorTestCase) HeaderContains(headerName string, value string) *CalculatorTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *CalculatorTestCase) HeaderNotContains(headerName string, value string) *CalculatorTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotContains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderEqual asserts no error and that the named header matches the value.
func (tc *CalculatorTestCase) HeaderEqual(headerName string, value string) *CalculatorTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderNotEqual asserts no error and that the named header does not matche the value.
func (tc *CalculatorTestCase) HeaderNotEqual(headerName string, value string) *CalculatorTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *CalculatorTestCase) HeaderExists(headerName string) *CalculatorTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s does not exist", headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header does not exists.
func (tc *CalculatorTestCase) HeaderNotExists(headerName string) *CalculatorTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s exists", headerName)
	}
	return tc
}

// ContentType asserts no error and that the Content-Type header matches the expected value.
func (tc *CalculatorTestCase) ContentType(expected string) *CalculatorTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, expected, tc.res.Header.Get("Content-Type"))
	}
	return tc
}

/*
TagExists asserts no error and that the at least one tag matches the CSS selector query.

Examples:

	TagExists(`TR > TD > A.expandable[href]`)
	TagExists(`DIV#main_panel`)
	TagExists(`TR TD INPUT[name="x"]`)
*/
func (tc *CalculatorTestCase) TagExists(cssSelectorQuery string) *CalculatorTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.NotEqual(tc.t, 0, len(matches), "Found no tags matching %s", cssSelectorQuery)
	}
	return tc
}

/*
TagNotExists asserts no error and that the no tag matches the CSS selector query.

Example:

	TagNotExists(`TR > TD > A.expandable[href]`)
	TagNotExists(`DIV#main_panel`)
	TagNotExists(`TR TD INPUT[name="x"]`)
*/
func (tc *CalculatorTestCase) TagNotExists(cssSelectorQuery string) *CalculatorTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.Equal(tc.t, 0, len(matches), "Found %d tag(s) matching %s", len(matches), cssSelectorQuery)
	}
	return tc
}

/*
TagEqual asserts no error and that the at least one of the tags matching the CSS selector query
either contains the exact text itself or has a descendant that does.

Example:

	TagEqual("TR > TD > A.expandable[href]", "Expand")
	TagEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *CalculatorTestCase) TagEqual(cssSelectorQuery string, value string) *CalculatorTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagContains asserts no error and that the at least one of the tags matching the CSS selector query
either contains the text itself or has a descendant that does.

Example:

	TagContains("TR > TD > A.expandable[href]", "Expand")
	TagContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *CalculatorTestCase) TagContains(cssSelectorQuery string, value string) *CalculatorTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotEqual asserts no error and that there is no tag matching the CSS selector that
either contains the exact text itself or has a descendant that does.

Example:

	TagNotEqual("TR > TD > A[href]", "Harry Potter")
	TagNotEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *CalculatorTestCase) TagNotEqual(cssSelectorQuery string, value string) *CalculatorTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotContains asserts no error and that there is no tag matching the CSS selector that
either contains the text itself or has a descendant that does.

Example:

	TagNotContains("TR > TD > A[href]", "Harry Potter")
	TagNotContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *CalculatorTestCase) TagNotContains(cssSelectorQuery string, value string) *CalculatorTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

// Error asserts an error.
func (tc *CalculatorTestCase) Error(errContains string) *CalculatorTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *CalculatorTestCase) ErrorCode(statusCode int) *CalculatorTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *CalculatorTestCase) NoError() *CalculatorTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *CalculatorTestCase) CompletedIn(threshold time.Duration) *CalculatorTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *CalculatorTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *CalculatorTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Calculator.
func (tc *CalculatorTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
Calculator_Get performs a GET request to the Calculator endpoint.

Calculator renders a UI for a calculator.
The calculation operation is delegated to another microservice in order to demonstrate
a call from one microservice to another.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Calculator_Get(t *testing.T, ctx context.Context, url string) *CalculatorTestCase {
	tc := &CalculatorTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfCalculator, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest("GET", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Calculator(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Calculator_Post performs a POST request to the Calculator endpoint.

Calculator renders a UI for a calculator.
The calculation operation is delegated to another microservice in order to demonstrate
a call from one microservice to another.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func Calculator_Post(t *testing.T, ctx context.Context, url string, contentType string, body any) *CalculatorTestCase {
	tc := &CalculatorTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfCalculator, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest("POST", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	err = httpx.SetRequestBody(r, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Calculator(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Calculator renders a UI for a calculator.
The calculation operation is delegated to another microservice in order to demonstrate
a call from one microservice to another.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Calculator(t *testing.T, r *http.Request) *CalculatorTestCase {
	tc := &CalculatorTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	url, err := httpx.ResolveURL(helloapi.URLOfCalculator, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = httpx.ParseURL(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	for k, vv := range frame.Of(r.Context()).Header() {
		r.Header[k] = vv
	}
	ctx := frame.ContextWithFrameOf(r.Context(), r.Header)
	r = r.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Calculator(w, r)
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// BusPNGTestCase assists in asserting against the results of executing BusPNG.
type BusPNGTestCase struct {
	t *testing.T
	dur time.Duration
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *BusPNGTestCase) StatusOK() *BusPNGTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *BusPNGTestCase) StatusCode(statusCode int) *BusPNGTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response body contains the string or byte array value.
func (tc *BusPNGTestCase) BodyContains(value any) *BusPNGTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.True(tc.t, bytes.Contains(body, v), "%v does not contain %v", body, v)
		case string:
			testarossa.Contains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.Contains(tc.t, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response body does not contain the string or byte array value.
func (tc *BusPNGTestCase) BodyNotContains(value any) *BusPNGTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.False(tc.t, bytes.Contains(body, v), "%v contains %v", body, v)
		case string:
			testarossa.NotContains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.NotContains(tc.t, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains the value.
func (tc *BusPNGTestCase) HeaderContains(headerName string, value string) *BusPNGTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *BusPNGTestCase) HeaderNotContains(headerName string, value string) *BusPNGTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotContains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderEqual asserts no error and that the named header matches the value.
func (tc *BusPNGTestCase) HeaderEqual(headerName string, value string) *BusPNGTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderNotEqual asserts no error and that the named header does not matche the value.
func (tc *BusPNGTestCase) HeaderNotEqual(headerName string, value string) *BusPNGTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *BusPNGTestCase) HeaderExists(headerName string) *BusPNGTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s does not exist", headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header does not exists.
func (tc *BusPNGTestCase) HeaderNotExists(headerName string) *BusPNGTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s exists", headerName)
	}
	return tc
}

// ContentType asserts no error and that the Content-Type header matches the expected value.
func (tc *BusPNGTestCase) ContentType(expected string) *BusPNGTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, expected, tc.res.Header.Get("Content-Type"))
	}
	return tc
}

/*
TagExists asserts no error and that the at least one tag matches the CSS selector query.

Examples:

	TagExists(`TR > TD > A.expandable[href]`)
	TagExists(`DIV#main_panel`)
	TagExists(`TR TD INPUT[name="x"]`)
*/
func (tc *BusPNGTestCase) TagExists(cssSelectorQuery string) *BusPNGTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.NotEqual(tc.t, 0, len(matches), "Found no tags matching %s", cssSelectorQuery)
	}
	return tc
}

/*
TagNotExists asserts no error and that the no tag matches the CSS selector query.

Example:

	TagNotExists(`TR > TD > A.expandable[href]`)
	TagNotExists(`DIV#main_panel`)
	TagNotExists(`TR TD INPUT[name="x"]`)
*/
func (tc *BusPNGTestCase) TagNotExists(cssSelectorQuery string) *BusPNGTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.Equal(tc.t, 0, len(matches), "Found %d tag(s) matching %s", len(matches), cssSelectorQuery)
	}
	return tc
}

/*
TagEqual asserts no error and that the at least one of the tags matching the CSS selector query
either contains the exact text itself or has a descendant that does.

Example:

	TagEqual("TR > TD > A.expandable[href]", "Expand")
	TagEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *BusPNGTestCase) TagEqual(cssSelectorQuery string, value string) *BusPNGTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagContains asserts no error and that the at least one of the tags matching the CSS selector query
either contains the text itself or has a descendant that does.

Example:

	TagContains("TR > TD > A.expandable[href]", "Expand")
	TagContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *BusPNGTestCase) TagContains(cssSelectorQuery string, value string) *BusPNGTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotEqual asserts no error and that there is no tag matching the CSS selector that
either contains the exact text itself or has a descendant that does.

Example:

	TagNotEqual("TR > TD > A[href]", "Harry Potter")
	TagNotEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *BusPNGTestCase) TagNotEqual(cssSelectorQuery string, value string) *BusPNGTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotContains asserts no error and that there is no tag matching the CSS selector that
either contains the text itself or has a descendant that does.

Example:

	TagNotContains("TR > TD > A[href]", "Harry Potter")
	TagNotContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *BusPNGTestCase) TagNotContains(cssSelectorQuery string, value string) *BusPNGTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

// Error asserts an error.
func (tc *BusPNGTestCase) Error(errContains string) *BusPNGTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *BusPNGTestCase) ErrorCode(statusCode int) *BusPNGTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *BusPNGTestCase) NoError() *BusPNGTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *BusPNGTestCase) CompletedIn(threshold time.Duration) *BusPNGTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *BusPNGTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *BusPNGTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing BusPNG.
func (tc *BusPNGTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}
/*
BusPNG serves an image from the embedded resources.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func BusPNG(t *testing.T, ctx context.Context, url string) *BusPNGTestCase {
	tc := &BusPNGTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfBusPNG, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.BusPNG(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
BusPNG_Do performs a customized request to the BusPNG endpoint.

BusPNG serves an image from the embedded resources.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func BusPNG_Do(t *testing.T, r *http.Request) *BusPNGTestCase {
	tc := &BusPNGTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	if r.Method != `GET` {
		tc.err = errors.Newc(http.StatusNotFound, "")
		return tc
	}
	url, err := httpx.ResolveURL(helloapi.URLOfBusPNG, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = httpx.ParseURL(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	for k, vv := range frame.Of(r.Context()).Header() {
		r.Header[k] = vv
	}
	ctx := frame.ContextWithFrameOf(r.Context(), r.Header)
	r = r.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.BusPNG(w, r)
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// LocalizationTestCase assists in asserting against the results of executing Localization.
type LocalizationTestCase struct {
	t *testing.T
	dur time.Duration
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *LocalizationTestCase) StatusOK() *LocalizationTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *LocalizationTestCase) StatusCode(statusCode int) *LocalizationTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response body contains the string or byte array value.
func (tc *LocalizationTestCase) BodyContains(value any) *LocalizationTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.True(tc.t, bytes.Contains(body, v), "%v does not contain %v", body, v)
		case string:
			testarossa.Contains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.Contains(tc.t, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response body does not contain the string or byte array value.
func (tc *LocalizationTestCase) BodyNotContains(value any) *LocalizationTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.False(tc.t, bytes.Contains(body, v), "%v contains %v", body, v)
		case string:
			testarossa.NotContains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.NotContains(tc.t, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains the value.
func (tc *LocalizationTestCase) HeaderContains(headerName string, value string) *LocalizationTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *LocalizationTestCase) HeaderNotContains(headerName string, value string) *LocalizationTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotContains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderEqual asserts no error and that the named header matches the value.
func (tc *LocalizationTestCase) HeaderEqual(headerName string, value string) *LocalizationTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderNotEqual asserts no error and that the named header does not matche the value.
func (tc *LocalizationTestCase) HeaderNotEqual(headerName string, value string) *LocalizationTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *LocalizationTestCase) HeaderExists(headerName string) *LocalizationTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s does not exist", headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header does not exists.
func (tc *LocalizationTestCase) HeaderNotExists(headerName string) *LocalizationTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s exists", headerName)
	}
	return tc
}

// ContentType asserts no error and that the Content-Type header matches the expected value.
func (tc *LocalizationTestCase) ContentType(expected string) *LocalizationTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, expected, tc.res.Header.Get("Content-Type"))
	}
	return tc
}

/*
TagExists asserts no error and that the at least one tag matches the CSS selector query.

Examples:

	TagExists(`TR > TD > A.expandable[href]`)
	TagExists(`DIV#main_panel`)
	TagExists(`TR TD INPUT[name="x"]`)
*/
func (tc *LocalizationTestCase) TagExists(cssSelectorQuery string) *LocalizationTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.NotEqual(tc.t, 0, len(matches), "Found no tags matching %s", cssSelectorQuery)
	}
	return tc
}

/*
TagNotExists asserts no error and that the no tag matches the CSS selector query.

Example:

	TagNotExists(`TR > TD > A.expandable[href]`)
	TagNotExists(`DIV#main_panel`)
	TagNotExists(`TR TD INPUT[name="x"]`)
*/
func (tc *LocalizationTestCase) TagNotExists(cssSelectorQuery string) *LocalizationTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.Equal(tc.t, 0, len(matches), "Found %d tag(s) matching %s", len(matches), cssSelectorQuery)
	}
	return tc
}

/*
TagEqual asserts no error and that the at least one of the tags matching the CSS selector query
either contains the exact text itself or has a descendant that does.

Example:

	TagEqual("TR > TD > A.expandable[href]", "Expand")
	TagEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *LocalizationTestCase) TagEqual(cssSelectorQuery string, value string) *LocalizationTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagContains asserts no error and that the at least one of the tags matching the CSS selector query
either contains the text itself or has a descendant that does.

Example:

	TagContains("TR > TD > A.expandable[href]", "Expand")
	TagContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *LocalizationTestCase) TagContains(cssSelectorQuery string, value string) *LocalizationTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotEqual asserts no error and that there is no tag matching the CSS selector that
either contains the exact text itself or has a descendant that does.

Example:

	TagNotEqual("TR > TD > A[href]", "Harry Potter")
	TagNotEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *LocalizationTestCase) TagNotEqual(cssSelectorQuery string, value string) *LocalizationTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotContains asserts no error and that there is no tag matching the CSS selector that
either contains the text itself or has a descendant that does.

Example:

	TagNotContains("TR > TD > A[href]", "Harry Potter")
	TagNotContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *LocalizationTestCase) TagNotContains(cssSelectorQuery string, value string) *LocalizationTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

// Error asserts an error.
func (tc *LocalizationTestCase) Error(errContains string) *LocalizationTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *LocalizationTestCase) ErrorCode(statusCode int) *LocalizationTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *LocalizationTestCase) NoError() *LocalizationTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *LocalizationTestCase) CompletedIn(threshold time.Duration) *LocalizationTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *LocalizationTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *LocalizationTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Localization.
func (tc *LocalizationTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
Localization_Get performs a GET request to the Localization endpoint.

Localization prints hello in the language best matching the request's Accept-Language header.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Localization_Get(t *testing.T, ctx context.Context, url string) *LocalizationTestCase {
	tc := &LocalizationTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfLocalization, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest("GET", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Localization(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Localization_Post performs a POST request to the Localization endpoint.

Localization prints hello in the language best matching the request's Accept-Language header.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func Localization_Post(t *testing.T, ctx context.Context, url string, contentType string, body any) *LocalizationTestCase {
	tc := &LocalizationTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfLocalization, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest("POST", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	err = httpx.SetRequestBody(r, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Localization(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Localization prints hello in the language best matching the request's Accept-Language header.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Localization(t *testing.T, r *http.Request) *LocalizationTestCase {
	tc := &LocalizationTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	url, err := httpx.ResolveURL(helloapi.URLOfLocalization, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = httpx.ParseURL(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	for k, vv := range frame.Of(r.Context()).Header() {
		r.Header[k] = vv
	}
	ctx := frame.ContextWithFrameOf(r.Context(), r.Header)
	r = r.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Localization(w, r)
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// RootTestCase assists in asserting against the results of executing Root.
type RootTestCase struct {
	t *testing.T
	dur time.Duration
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *RootTestCase) StatusOK() *RootTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *RootTestCase) StatusCode(statusCode int) *RootTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response body contains the string or byte array value.
func (tc *RootTestCase) BodyContains(value any) *RootTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.True(tc.t, bytes.Contains(body, v), "%v does not contain %v", body, v)
		case string:
			testarossa.Contains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.Contains(tc.t, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response body does not contain the string or byte array value.
func (tc *RootTestCase) BodyNotContains(value any) *RootTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.False(tc.t, bytes.Contains(body, v), "%v contains %v", body, v)
		case string:
			testarossa.NotContains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.NotContains(tc.t, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains the value.
func (tc *RootTestCase) HeaderContains(headerName string, value string) *RootTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *RootTestCase) HeaderNotContains(headerName string, value string) *RootTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotContains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderEqual asserts no error and that the named header matches the value.
func (tc *RootTestCase) HeaderEqual(headerName string, value string) *RootTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderNotEqual asserts no error and that the named header does not matche the value.
func (tc *RootTestCase) HeaderNotEqual(headerName string, value string) *RootTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *RootTestCase) HeaderExists(headerName string) *RootTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s does not exist", headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header does not exists.
func (tc *RootTestCase) HeaderNotExists(headerName string) *RootTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s exists", headerName)
	}
	return tc
}

// ContentType asserts no error and that the Content-Type header matches the expected value.
func (tc *RootTestCase) ContentType(expected string) *RootTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, expected, tc.res.Header.Get("Content-Type"))
	}
	return tc
}

/*
TagExists asserts no error and that the at least one tag matches the CSS selector query.

Examples:

	TagExists(`TR > TD > A.expandable[href]`)
	TagExists(`DIV#main_panel`)
	TagExists(`TR TD INPUT[name="x"]`)
*/
func (tc *RootTestCase) TagExists(cssSelectorQuery string) *RootTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.NotEqual(tc.t, 0, len(matches), "Found no tags matching %s", cssSelectorQuery)
	}
	return tc
}

/*
TagNotExists asserts no error and that the no tag matches the CSS selector query.

Example:

	TagNotExists(`TR > TD > A.expandable[href]`)
	TagNotExists(`DIV#main_panel`)
	TagNotExists(`TR TD INPUT[name="x"]`)
*/
func (tc *RootTestCase) TagNotExists(cssSelectorQuery string) *RootTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.Equal(tc.t, 0, len(matches), "Found %d tag(s) matching %s", len(matches), cssSelectorQuery)
	}
	return tc
}

/*
TagEqual asserts no error and that the at least one of the tags matching the CSS selector query
either contains the exact text itself or has a descendant that does.

Example:

	TagEqual("TR > TD > A.expandable[href]", "Expand")
	TagEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *RootTestCase) TagEqual(cssSelectorQuery string, value string) *RootTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagContains asserts no error and that the at least one of the tags matching the CSS selector query
either contains the text itself or has a descendant that does.

Example:

	TagContains("TR > TD > A.expandable[href]", "Expand")
	TagContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *RootTestCase) TagContains(cssSelectorQuery string, value string) *RootTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotEqual asserts no error and that there is no tag matching the CSS selector that
either contains the exact text itself or has a descendant that does.

Example:

	TagNotEqual("TR > TD > A[href]", "Harry Potter")
	TagNotEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *RootTestCase) TagNotEqual(cssSelectorQuery string, value string) *RootTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotContains asserts no error and that there is no tag matching the CSS selector that
either contains the text itself or has a descendant that does.

Example:

	TagNotContains("TR > TD > A[href]", "Harry Potter")
	TagNotContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *RootTestCase) TagNotContains(cssSelectorQuery string, value string) *RootTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

// Error asserts an error.
func (tc *RootTestCase) Error(errContains string) *RootTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *RootTestCase) ErrorCode(statusCode int) *RootTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *RootTestCase) NoError() *RootTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *RootTestCase) CompletedIn(threshold time.Duration) *RootTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *RootTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *RootTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Root.
func (tc *RootTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
Root_Get performs a GET request to the Root endpoint.

Root is the top-most root page.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Root_Get(t *testing.T, ctx context.Context, url string) *RootTestCase {
	tc := &RootTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfRoot, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest("GET", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Root(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Root_Post performs a POST request to the Root endpoint.

Root is the top-most root page.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func Root_Post(t *testing.T, ctx context.Context, url string, contentType string, body any) *RootTestCase {
	tc := &RootTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfRoot, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest("POST", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	err = httpx.SetRequestBody(r, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Root(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Root is the top-most root page.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Root(t *testing.T, r *http.Request) *RootTestCase {
	tc := &RootTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	url, err := httpx.ResolveURL(helloapi.URLOfRoot, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = httpx.ParseURL(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	for k, vv := range frame.Of(r.Context()).Header() {
		r.Header[k] = vv
	}
	ctx := frame.ContextWithFrameOf(r.Context(), r.Header)
	r = r.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Root(w, r)
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// TickTockTestCase assists in asserting against the results of executing TickTock.
type TickTockTestCase struct {
	t *testing.T
	dur time.Duration
	err error
}

// Error asserts an error.
func (tc *TickTockTestCase) Error(errContains string) *TickTockTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *TickTockTestCase) ErrorCode(statusCode int) *TickTockTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *TickTockTestCase) NoError() *TickTockTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *TickTockTestCase) CompletedIn(threshold time.Duration) *TickTockTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *TickTockTestCase) Assert(asserter func(t *testing.T, err error)) *TickTockTestCase {
	asserter(tc.t, tc.err)
	return tc
}

// Get returns the result of executing TickTock.
func (tc *TickTockTestCase) Get() (err error) {
	return tc.err
}

// TickTock executes the ticker and returns a corresponding test case.
func TickTock(t *testing.T, ctx context.Context) *TickTockTestCase {
	tc := &TickTockTestCase{t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.TickTock(ctx)
	})
	tc.dur = time.Since(t0)
	return tc
}
