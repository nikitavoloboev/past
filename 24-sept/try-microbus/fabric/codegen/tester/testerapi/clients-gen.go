/*
Copyright (c) 2023-2024 Microbus LLC and various contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Microbus. DO NOT EDIT.

/*
Package testerapi implements the public API of the codegen.test microservice,
including clients and data structures.

The tester is used to test the code generator's functions.
*/
package testerapi

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/service"
	"github.com/microbus-io/fabric/sub"
)

var (
	_ context.Context
	_ *json.Decoder
	_ io.Reader
	_ *http.Request
	_ *url.URL
	_ strings.Reader
	_ time.Duration
	_ *errors.TracedError
	_ *httpx.BodyReader
	_ pub.Option
	_ sub.Option
)

// Hostname is the default hostname of the microservice: codegen.test.
const Hostname = "codegen.test"

// Fully-qualified URLs of the microservice's endpoints.
var (
	URLOfStringCut = httpx.JoinHostAndPath(Hostname, `:443/string-cut`)
	URLOfPointDistance = httpx.JoinHostAndPath(Hostname, `:443/point-distance`)
	URLOfShiftPoint = httpx.JoinHostAndPath(Hostname, `:443/shift-point`)
	URLOfLinesIntersection = httpx.JoinHostAndPath(Hostname, `:443/lines-intersection`)
	URLOfSubArrayRange = httpx.JoinHostAndPath(Hostname, `:443/sub-array-range/{max}`)
	URLOfSumTwoIntegers = httpx.JoinHostAndPath(Hostname, `:443/sum-two-integers`)
	URLOfFunctionPathArguments = httpx.JoinHostAndPath(Hostname, `:443/function-path-arguments/fixed/{named}/{}/{suffix+}`)
	URLOfNonStringPathArguments = httpx.JoinHostAndPath(Hostname, `:443/non-string-path-arguments/fixed/{named}/{}/{suffix+}`)
	URLOfUnnamedFunctionPathArguments = httpx.JoinHostAndPath(Hostname, `:443/unnamed-function-path-arguments/{}/foo/{}/bar/{+}`)
	URLOfPathArgumentsPriority = httpx.JoinHostAndPath(Hostname, `:443/path-arguments-priority/{foo}`)
	URLOfWhatTimeIsIt = httpx.JoinHostAndPath(Hostname, `:443/what-time-is-it`)
	URLOfEcho = httpx.JoinHostAndPath(Hostname, `:443/echo`)
	URLOfMultiValueHeaders = httpx.JoinHostAndPath(Hostname, `:443/multi-value-headers`)
	URLOfWebPathArguments = httpx.JoinHostAndPath(Hostname, `:443/web-path-arguments/fixed/{named}/{}/{suffix+}`)
	URLOfUnnamedWebPathArguments = httpx.JoinHostAndPath(Hostname, `:443/unnamed-web-path-arguments/{}/foo/{}/bar/{+}`)
	URLOfDirectoryServer = httpx.JoinHostAndPath(Hostname, `:443/directory-server/{filename+}`)
	URLOfHello = httpx.JoinHostAndPath(Hostname, `:443/hello`)
)

// Client is an interface to calling the endpoints of the codegen.test microservice.
// This simple version is for unicast calls.
type Client struct {
	svc  service.Publisher
	host string
}

// NewClient creates a new unicast client to the codegen.test microservice.
func NewClient(caller service.Publisher) *Client {
	return &Client{
		svc:  caller,
		host: "codegen.test",
	}
}

// ForHost replaces the default hostname of this client.
func (_c *Client) ForHost(host string) *Client {
	_c.host = host
	return _c
}

// MulticastClient is an interface to calling the endpoints of the codegen.test microservice.
// This advanced version is for multicast calls.
type MulticastClient struct {
	svc  service.Publisher
	host string
}

// NewMulticastClient creates a new multicast client to the codegen.test microservice.
func NewMulticastClient(caller service.Publisher) *MulticastClient {
	return &MulticastClient{
		svc:  caller,
		host: "codegen.test",
	}
}

// ForHost replaces the default hostname of this client.
func (_c *MulticastClient) ForHost(host string) *MulticastClient {
	_c.host = host
	return _c
}

// MulticastTrigger is an interface to trigger the events of the codegen.test microservice.
type MulticastTrigger struct {
	svc  service.Publisher
	host string
}

// NewMulticastTrigger creates a new multicast trigger of the codegen.test microservice.
func NewMulticastTrigger(caller service.Publisher) *MulticastTrigger {
	return &MulticastTrigger{
		svc:  caller,
		host: "codegen.test",
	}
}

// ForHost replaces the default hostname of this trigger.
func (_c *MulticastTrigger) ForHost(host string) *MulticastTrigger {
	_c.host = host
	return _c
}

// Hook assists in the subscription to the events of the codegen.test microservice.
type Hook struct {
	svc  service.Subscriber
	host string
}

// NewHook creates a new hook to the events of the codegen.test microservice.
func NewHook(listener service.Subscriber) *Hook {
	return &Hook{
		svc:  listener,
		host: "codegen.test",
	}
}

// ForHost replaces the default hostname of this hook.
func (_c *Hook) ForHost(host string) *Hook {
	_c.host = host
	return _c
}

// errChan returns a response channel with a single error response.
func (_c *MulticastClient) errChan(err error) <-chan *pub.Response {
	ch := make(chan *pub.Response, 1)
	ch <- pub.NewErrorResponse(err)
	close(ch)
	return ch
}

/*
Echo_Get performs a GET request to the Echo endpoint.

Echo tests a typical web handler.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) Echo_Get(ctx context.Context, url string) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfEcho, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("GET"), pub.URL(url))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
Echo_Get performs a GET request to the Echo endpoint.

Echo tests a typical web handler.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) Echo_Get(ctx context.Context, url string) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfEcho, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("GET"), pub.URL(url))
}

/*
Echo_Post performs a POST request to the Echo endpoint.

Echo tests a typical web handler.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *Client) Echo_Post(ctx context.Context, url string, contentType string, body any) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfEcho, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
Echo_Post performs a POST request to the Echo endpoint.

Echo tests a typical web handler.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *MulticastClient) Echo_Post(ctx context.Context, url string, contentType string, body any) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfEcho, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
}

/*
Echo tests a typical web handler.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) Echo(r *http.Request) (res *http.Response, err error) {
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return nil, errors.Trace(err)
		}
	}
	url, err := httpx.ResolveURL(URLOfEcho, r.URL.String())
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(r.Context(), pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
Echo tests a typical web handler.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) Echo(ctx context.Context, r *http.Request) <-chan *pub.Response {
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return _c.errChan(errors.Trace(err))
		}
	}
	url, err := httpx.ResolveURL(URLOfEcho, r.URL.String())
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
}

/*
MultiValueHeaders_Get performs a GET request to the MultiValueHeaders endpoint.

MultiValueHeaders tests a passing in and returning headers with multiple values.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) MultiValueHeaders_Get(ctx context.Context, url string) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfMultiValueHeaders, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("GET"), pub.URL(url))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
MultiValueHeaders_Get performs a GET request to the MultiValueHeaders endpoint.

MultiValueHeaders tests a passing in and returning headers with multiple values.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) MultiValueHeaders_Get(ctx context.Context, url string) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfMultiValueHeaders, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("GET"), pub.URL(url))
}

/*
MultiValueHeaders_Post performs a POST request to the MultiValueHeaders endpoint.

MultiValueHeaders tests a passing in and returning headers with multiple values.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *Client) MultiValueHeaders_Post(ctx context.Context, url string, contentType string, body any) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfMultiValueHeaders, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
MultiValueHeaders_Post performs a POST request to the MultiValueHeaders endpoint.

MultiValueHeaders tests a passing in and returning headers with multiple values.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *MulticastClient) MultiValueHeaders_Post(ctx context.Context, url string, contentType string, body any) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfMultiValueHeaders, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
}

/*
MultiValueHeaders tests a passing in and returning headers with multiple values.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) MultiValueHeaders(r *http.Request) (res *http.Response, err error) {
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return nil, errors.Trace(err)
		}
	}
	url, err := httpx.ResolveURL(URLOfMultiValueHeaders, r.URL.String())
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(r.Context(), pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
MultiValueHeaders tests a passing in and returning headers with multiple values.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) MultiValueHeaders(ctx context.Context, r *http.Request) <-chan *pub.Response {
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return _c.errChan(errors.Trace(err))
		}
	}
	url, err := httpx.ResolveURL(URLOfMultiValueHeaders, r.URL.String())
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
}

/*
WebPathArguments_Get performs a GET request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) WebPathArguments_Get(ctx context.Context, url string) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfWebPathArguments, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("GET"), pub.URL(url))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
WebPathArguments_Get performs a GET request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) WebPathArguments_Get(ctx context.Context, url string) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfWebPathArguments, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("GET"), pub.URL(url))
}

/*
WebPathArguments_Post performs a POST request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *Client) WebPathArguments_Post(ctx context.Context, url string, contentType string, body any) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfWebPathArguments, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
WebPathArguments_Post performs a POST request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *MulticastClient) WebPathArguments_Post(ctx context.Context, url string, contentType string, body any) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfWebPathArguments, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
}

/*
WebPathArguments tests path arguments in web handlers.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) WebPathArguments(r *http.Request) (res *http.Response, err error) {
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return nil, errors.Trace(err)
		}
	}
	url, err := httpx.ResolveURL(URLOfWebPathArguments, r.URL.String())
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(r.Context(), pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
WebPathArguments tests path arguments in web handlers.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) WebPathArguments(ctx context.Context, r *http.Request) <-chan *pub.Response {
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return _c.errChan(errors.Trace(err))
		}
	}
	url, err := httpx.ResolveURL(URLOfWebPathArguments, r.URL.String())
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
}

/*
UnnamedWebPathArguments tests path arguments that are not named.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) UnnamedWebPathArguments(ctx context.Context, url string) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfUnnamedWebPathArguments, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method(`GET`), pub.URL(url))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
UnnamedWebPathArguments tests path arguments that are not named.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) UnnamedWebPathArguments(ctx context.Context, url string) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfUnnamedWebPathArguments, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(`GET`), pub.URL(url))
}

/*
UnnamedWebPathArguments_Do performs a customized request to the UnnamedWebPathArguments endpoint.

UnnamedWebPathArguments tests path arguments that are not named.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) UnnamedWebPathArguments_Do(r *http.Request) (res *http.Response, err error) {
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return nil, errors.Trace(err)
		}
	}
	if r.Method != `GET` {
		return nil, errors.Newc(http.StatusNotFound, "")
	}
	url, err := httpx.ResolveURL(URLOfUnnamedWebPathArguments, r.URL.String())
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(r.Context(), pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
UnnamedWebPathArguments_Do performs a customized request to the UnnamedWebPathArguments endpoint.

UnnamedWebPathArguments tests path arguments that are not named.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) UnnamedWebPathArguments_Do(ctx context.Context, r *http.Request) <-chan *pub.Response {
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return _c.errChan(errors.Trace(err))
		}
	}
	if r.Method != `GET` {
		return _c.errChan(errors.Newc(http.StatusNotFound, ""))
	}
	url, err := httpx.ResolveURL(URLOfUnnamedWebPathArguments, r.URL.String())
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
}

/*
DirectoryServer tests service resources given a greedy path argument.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) DirectoryServer(ctx context.Context, url string) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfDirectoryServer, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method(`GET`), pub.URL(url))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
DirectoryServer tests service resources given a greedy path argument.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) DirectoryServer(ctx context.Context, url string) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfDirectoryServer, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(`GET`), pub.URL(url))
}

/*
DirectoryServer_Do performs a customized request to the DirectoryServer endpoint.

DirectoryServer tests service resources given a greedy path argument.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) DirectoryServer_Do(r *http.Request) (res *http.Response, err error) {
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return nil, errors.Trace(err)
		}
	}
	if r.Method != `GET` {
		return nil, errors.Newc(http.StatusNotFound, "")
	}
	url, err := httpx.ResolveURL(URLOfDirectoryServer, r.URL.String())
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(r.Context(), pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
DirectoryServer_Do performs a customized request to the DirectoryServer endpoint.

DirectoryServer tests service resources given a greedy path argument.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) DirectoryServer_Do(ctx context.Context, r *http.Request) <-chan *pub.Response {
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return _c.errChan(errors.Trace(err))
		}
	}
	if r.Method != `GET` {
		return _c.errChan(errors.Newc(http.StatusNotFound, ""))
	}
	url, err := httpx.ResolveURL(URLOfDirectoryServer, r.URL.String())
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
}

/*
Hello_Get performs a GET request to the Hello endpoint.

Hello prints hello in the language best matching the request's Accept-Language header.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) Hello_Get(ctx context.Context, url string) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfHello, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("GET"), pub.URL(url))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
Hello_Get performs a GET request to the Hello endpoint.

Hello prints hello in the language best matching the request's Accept-Language header.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) Hello_Get(ctx context.Context, url string) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfHello, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("GET"), pub.URL(url))
}

/*
Hello_Post performs a POST request to the Hello endpoint.

Hello prints hello in the language best matching the request's Accept-Language header.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *Client) Hello_Post(ctx context.Context, url string, contentType string, body any) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfHello, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
Hello_Post performs a POST request to the Hello endpoint.

Hello prints hello in the language best matching the request's Accept-Language header.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *MulticastClient) Hello_Post(ctx context.Context, url string, contentType string, body any) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfHello, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
}

/*
Hello prints hello in the language best matching the request's Accept-Language header.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) Hello(r *http.Request) (res *http.Response, err error) {
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return nil, errors.Trace(err)
		}
	}
	url, err := httpx.ResolveURL(URLOfHello, r.URL.String())
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(r.Context(), pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
Hello prints hello in the language best matching the request's Accept-Language header.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) Hello(ctx context.Context, r *http.Request) <-chan *pub.Response {
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return _c.errChan(errors.Trace(err))
		}
	}
	url, err := httpx.ResolveURL(URLOfHello, r.URL.String())
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
}

// StringCutIn are the input arguments of StringCut.
type StringCutIn struct {
	S string `json:"s"`
	Sep string `json:"sep"`
}

// StringCutOut are the return values of StringCut.
type StringCutOut struct {
	Before string `json:"before"`
	After string `json:"after"`
	Found bool `json:"found"`
}

// StringCutResponse is the response to StringCut.
type StringCutResponse struct {
	data StringCutOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *StringCutResponse) Get() (before string, after string, found bool, err error) {
	before = _out.data.Before
	after = _out.data.After
	found = _out.data.Found
	err = _out.err
	return
}

/*
StringCut tests a function that takes primitive input arguments and returns primitive values.
*/
func (_c *MulticastClient) StringCut(ctx context.Context, s string, sep string) <-chan *StringCutResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/string-cut`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`s`: s,
		`sep`: sep,
	})
	_in := StringCutIn{
		s,
		sep,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *StringCutResponse, cap(_ch))
	for _i := range _ch {
		var _r StringCutResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
StringCut tests a function that takes primitive input arguments and returns primitive values.
*/
func (_c *Client) StringCut(ctx context.Context, s string, sep string) (before string, after string, found bool, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/string-cut`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`s`: s,
		`sep`: sep,
	})
	_in := StringCutIn{
		s,
		sep,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out StringCutOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	before = _out.Before
	after = _out.After
	found = _out.Found
	return
}

// PointDistanceIn are the input arguments of PointDistance.
type PointDistanceIn struct {
	P1 XYCoord `json:"p1"`
	P2 *XYCoord `json:"p2"`
}

// PointDistanceOut are the return values of PointDistance.
type PointDistanceOut struct {
	D float64 `json:"d"`
}

// PointDistanceResponse is the response to PointDistance.
type PointDistanceResponse struct {
	data PointDistanceOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *PointDistanceResponse) Get() (d float64, err error) {
	d = _out.data.D
	err = _out.err
	return
}

/*
PointDistance tests a function that takes non-primitive input arguments.
*/
func (_c *MulticastClient) PointDistance(ctx context.Context, p1 XYCoord, p2 *XYCoord) <-chan *PointDistanceResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/point-distance`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`p1`: p1,
		`p2`: p2,
	})
	_in := PointDistanceIn{
		p1,
		p2,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *PointDistanceResponse, 1)
		_res <- &PointDistanceResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *PointDistanceResponse, cap(_ch))
	for _i := range _ch {
		var _r PointDistanceResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
PointDistance tests a function that takes non-primitive input arguments.
*/
func (_c *Client) PointDistance(ctx context.Context, p1 XYCoord, p2 *XYCoord) (d float64, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/point-distance`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`p1`: p1,
		`p2`: p2,
	})
	_in := PointDistanceIn{
		p1,
		p2,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out PointDistanceOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	d = _out.D
	return
}

// ShiftPointIn are the input arguments of ShiftPoint.
type ShiftPointIn struct {
	P *XYCoord `json:"p"`
	X float64 `json:"x"`
	Y float64 `json:"y"`
}

// ShiftPointOut are the return values of ShiftPoint.
type ShiftPointOut struct {
	Shifted *XYCoord `json:"shifted"`
}

// ShiftPointResponse is the response to ShiftPoint.
type ShiftPointResponse struct {
	data ShiftPointOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *ShiftPointResponse) Get() (shifted *XYCoord, err error) {
	shifted = _out.data.Shifted
	err = _out.err
	return
}

/*
ShiftPoint tests passing pointers of non-primitive types.
*/
func (_c *MulticastClient) ShiftPoint(ctx context.Context, p *XYCoord, x float64, y float64) <-chan *ShiftPointResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/shift-point`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`p`: p,
		`x`: x,
		`y`: y,
	})
	_in := ShiftPointIn{
		p,
		x,
		y,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *ShiftPointResponse, cap(_ch))
	for _i := range _ch {
		var _r ShiftPointResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
ShiftPoint tests passing pointers of non-primitive types.
*/
func (_c *Client) ShiftPoint(ctx context.Context, p *XYCoord, x float64, y float64) (shifted *XYCoord, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/shift-point`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`p`: p,
		`x`: x,
		`y`: y,
	})
	_in := ShiftPointIn{
		p,
		x,
		y,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out ShiftPointOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	shifted = _out.Shifted
	return
}

// LinesIntersectionIn are the input arguments of LinesIntersection.
type LinesIntersectionIn struct {
	L1 XYLine `json:"l1"`
	L2 *XYLine `json:"l2"`
}

// LinesIntersectionOut are the return values of LinesIntersection.
type LinesIntersectionOut struct {
	B bool `json:"b"`
}

// LinesIntersectionResponse is the response to LinesIntersection.
type LinesIntersectionResponse struct {
	data LinesIntersectionOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *LinesIntersectionResponse) Get() (b bool, err error) {
	b = _out.data.B
	err = _out.err
	return
}

/*
LinesIntersection tests nested non-primitive types.
*/
func (_c *MulticastClient) LinesIntersection(ctx context.Context, l1 XYLine, l2 *XYLine) <-chan *LinesIntersectionResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/lines-intersection`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`l1`: l1,
		`l2`: l2,
	})
	_in := LinesIntersectionIn{
		l1,
		l2,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *LinesIntersectionResponse, cap(_ch))
	for _i := range _ch {
		var _r LinesIntersectionResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
LinesIntersection tests nested non-primitive types.
*/
func (_c *Client) LinesIntersection(ctx context.Context, l1 XYLine, l2 *XYLine) (b bool, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/lines-intersection`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`l1`: l1,
		`l2`: l2,
	})
	_in := LinesIntersectionIn{
		l1,
		l2,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out LinesIntersectionOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	b = _out.B
	return
}

// SubArrayRangeIn are the input arguments of SubArrayRange.
type SubArrayRangeIn struct {
	HTTPRequestBody []int `json:"-"`
	Min int `json:"min"`
	Max int `json:"max"`
}

// SubArrayRangeOut are the return values of SubArrayRange.
type SubArrayRangeOut struct {
	HTTPResponseBody []int `json:"httpResponseBody"`
	HTTPStatusCode int `json:"-"`
}

// SubArrayRangeResponse is the response to SubArrayRange.
type SubArrayRangeResponse struct {
	data SubArrayRangeOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *SubArrayRangeResponse) Get() (httpResponseBody []int, httpStatusCode int, err error) {
	httpResponseBody = _out.data.HTTPResponseBody
	httpStatusCode = _out.data.HTTPStatusCode
	err = _out.err
	return
}

/*
SubArrayRange tests sending arguments as the entire request and response bodies.
An httpRequestBody argument allows sending other arguments via query or path.
An httpResponseBody argument prevents returning additional values, except for the status code.
*/
func (_c *MulticastClient) SubArrayRange(ctx context.Context, httpRequestBody []int, min int, max int) <-chan *SubArrayRangeResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/sub-array-range/{max}`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`min`: min,
		`max`: max,
	})
	_in := SubArrayRangeIn{
		httpRequestBody,
		min,
		max,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *SubArrayRangeResponse, 1)
		_res <- &SubArrayRangeResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	_body := httpRequestBody
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *SubArrayRangeResponse, cap(_ch))
	for _i := range _ch {
		var _r SubArrayRangeResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data.HTTPResponseBody))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
			_r.data.HTTPStatusCode = _httpRes.StatusCode
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
SubArrayRange tests sending arguments as the entire request and response bodies.
An httpRequestBody argument allows sending other arguments via query or path.
An httpResponseBody argument prevents returning additional values, except for the status code.
*/
func (_c *Client) SubArrayRange(ctx context.Context, httpRequestBody []int, min int, max int) (httpResponseBody []int, httpStatusCode int, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/sub-array-range/{max}`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`min`: min,
		`max`: max,
	})
	_in := SubArrayRangeIn{
		httpRequestBody,
		min,
		max,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	_body := httpRequestBody
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out SubArrayRangeOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out.HTTPResponseBody)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	_out.HTTPStatusCode = _httpRes.StatusCode
	httpResponseBody = _out.HTTPResponseBody
	httpStatusCode = _out.HTTPStatusCode
	return
}

// SumTwoIntegersIn are the input arguments of SumTwoIntegers.
type SumTwoIntegersIn struct {
	X int `json:"x"`
	Y int `json:"y"`
}

// SumTwoIntegersOut are the return values of SumTwoIntegers.
type SumTwoIntegersOut struct {
	Sum int `json:"sum"`
	HTTPStatusCode int `json:"-"`
}

// SumTwoIntegersResponse is the response to SumTwoIntegers.
type SumTwoIntegersResponse struct {
	data SumTwoIntegersOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *SumTwoIntegersResponse) Get() (sum int, httpStatusCode int, err error) {
	sum = _out.data.Sum
	httpStatusCode = _out.data.HTTPStatusCode
	err = _out.err
	return
}

/*
SumTwoIntegers tests returning a status code from a function.
*/
func (_c *MulticastClient) SumTwoIntegers(ctx context.Context, x int, y int) <-chan *SumTwoIntegersResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/sum-two-integers`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`x`: x,
		`y`: y,
	})
	_in := SumTwoIntegersIn{
		x,
		y,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *SumTwoIntegersResponse, cap(_ch))
	for _i := range _ch {
		var _r SumTwoIntegersResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
			_r.data.HTTPStatusCode = _httpRes.StatusCode
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
SumTwoIntegers tests returning a status code from a function.
*/
func (_c *Client) SumTwoIntegers(ctx context.Context, x int, y int) (sum int, httpStatusCode int, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/sum-two-integers`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`x`: x,
		`y`: y,
	})
	_in := SumTwoIntegersIn{
		x,
		y,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out SumTwoIntegersOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	_out.HTTPStatusCode = _httpRes.StatusCode
	sum = _out.Sum
	httpStatusCode = _out.HTTPStatusCode
	return
}

// FunctionPathArgumentsIn are the input arguments of FunctionPathArguments.
type FunctionPathArgumentsIn struct {
	Named string `json:"named"`
	Path2 string `json:"path2"`
	Suffix string `json:"suffix"`
}

// FunctionPathArgumentsOut are the return values of FunctionPathArguments.
type FunctionPathArgumentsOut struct {
	Joined string `json:"joined"`
}

// FunctionPathArgumentsResponse is the response to FunctionPathArguments.
type FunctionPathArgumentsResponse struct {
	data FunctionPathArgumentsOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *FunctionPathArgumentsResponse) Get() (joined string, err error) {
	joined = _out.data.Joined
	err = _out.err
	return
}

/*
FunctionPathArguments tests path arguments in functions.
*/
func (_c *MulticastClient) FunctionPathArguments(ctx context.Context, named string, path2 string, suffix string) <-chan *FunctionPathArgumentsResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/function-path-arguments/fixed/{named}/{}/{suffix+}`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`named`: named,
		`path2`: path2,
		`suffix`: suffix,
	})
	_in := FunctionPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *FunctionPathArgumentsResponse, 1)
		_res <- &FunctionPathArgumentsResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *FunctionPathArgumentsResponse, cap(_ch))
	for _i := range _ch {
		var _r FunctionPathArgumentsResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
FunctionPathArguments tests path arguments in functions.
*/
func (_c *Client) FunctionPathArguments(ctx context.Context, named string, path2 string, suffix string) (joined string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/function-path-arguments/fixed/{named}/{}/{suffix+}`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`named`: named,
		`path2`: path2,
		`suffix`: suffix,
	})
	_in := FunctionPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out FunctionPathArgumentsOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	joined = _out.Joined
	return
}

// NonStringPathArgumentsIn are the input arguments of NonStringPathArguments.
type NonStringPathArgumentsIn struct {
	Named int `json:"named"`
	Path2 bool `json:"path2"`
	Suffix float64 `json:"suffix"`
}

// NonStringPathArgumentsOut are the return values of NonStringPathArguments.
type NonStringPathArgumentsOut struct {
	Joined string `json:"joined"`
}

// NonStringPathArgumentsResponse is the response to NonStringPathArguments.
type NonStringPathArgumentsResponse struct {
	data NonStringPathArgumentsOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *NonStringPathArgumentsResponse) Get() (joined string, err error) {
	joined = _out.data.Joined
	err = _out.err
	return
}

/*
NonStringPathArguments tests path arguments that are not strings.
*/
func (_c *MulticastClient) NonStringPathArguments(ctx context.Context, named int, path2 bool, suffix float64) <-chan *NonStringPathArgumentsResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/non-string-path-arguments/fixed/{named}/{}/{suffix+}`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`named`: named,
		`path2`: path2,
		`suffix`: suffix,
	})
	_in := NonStringPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *NonStringPathArgumentsResponse, 1)
		_res <- &NonStringPathArgumentsResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *NonStringPathArgumentsResponse, cap(_ch))
	for _i := range _ch {
		var _r NonStringPathArgumentsResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
NonStringPathArguments tests path arguments that are not strings.
*/
func (_c *Client) NonStringPathArguments(ctx context.Context, named int, path2 bool, suffix float64) (joined string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/non-string-path-arguments/fixed/{named}/{}/{suffix+}`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`named`: named,
		`path2`: path2,
		`suffix`: suffix,
	})
	_in := NonStringPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out NonStringPathArgumentsOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	joined = _out.Joined
	return
}

// UnnamedFunctionPathArgumentsIn are the input arguments of UnnamedFunctionPathArguments.
type UnnamedFunctionPathArgumentsIn struct {
	Path1 string `json:"path1"`
	Path2 string `json:"path2"`
	Path3 string `json:"path3"`
}

// UnnamedFunctionPathArgumentsOut are the return values of UnnamedFunctionPathArguments.
type UnnamedFunctionPathArgumentsOut struct {
	Joined string `json:"joined"`
}

// UnnamedFunctionPathArgumentsResponse is the response to UnnamedFunctionPathArguments.
type UnnamedFunctionPathArgumentsResponse struct {
	data UnnamedFunctionPathArgumentsOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *UnnamedFunctionPathArgumentsResponse) Get() (joined string, err error) {
	joined = _out.data.Joined
	err = _out.err
	return
}

/*
UnnamedFunctionPathArguments tests path arguments that are not named.
*/
func (_c *MulticastClient) UnnamedFunctionPathArguments(ctx context.Context, path1 string, path2 string, path3 string) <-chan *UnnamedFunctionPathArgumentsResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/unnamed-function-path-arguments/{}/foo/{}/bar/{+}`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`path1`: path1,
		`path2`: path2,
		`path3`: path3,
	})
	_in := UnnamedFunctionPathArgumentsIn{
		path1,
		path2,
		path3,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *UnnamedFunctionPathArgumentsResponse, 1)
		_res <- &UnnamedFunctionPathArgumentsResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *UnnamedFunctionPathArgumentsResponse, cap(_ch))
	for _i := range _ch {
		var _r UnnamedFunctionPathArgumentsResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
UnnamedFunctionPathArguments tests path arguments that are not named.
*/
func (_c *Client) UnnamedFunctionPathArguments(ctx context.Context, path1 string, path2 string, path3 string) (joined string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/unnamed-function-path-arguments/{}/foo/{}/bar/{+}`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`path1`: path1,
		`path2`: path2,
		`path3`: path3,
	})
	_in := UnnamedFunctionPathArgumentsIn{
		path1,
		path2,
		path3,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out UnnamedFunctionPathArgumentsOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	joined = _out.Joined
	return
}

// PathArgumentsPriorityIn are the input arguments of PathArgumentsPriority.
type PathArgumentsPriorityIn struct {
	Foo string `json:"foo"`
}

// PathArgumentsPriorityOut are the return values of PathArgumentsPriority.
type PathArgumentsPriorityOut struct {
	Echo string `json:"echo"`
}

// PathArgumentsPriorityResponse is the response to PathArgumentsPriority.
type PathArgumentsPriorityResponse struct {
	data PathArgumentsPriorityOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *PathArgumentsPriorityResponse) Get() (echo string, err error) {
	echo = _out.data.Echo
	err = _out.err
	return
}

/*
PathArgumentsPriority tests the priority of path arguments in functions.
*/
func (_c *MulticastClient) PathArgumentsPriority(ctx context.Context, foo string) <-chan *PathArgumentsPriorityResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/path-arguments-priority/{foo}`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`foo`: foo,
	})
	_in := PathArgumentsPriorityIn{
		foo,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *PathArgumentsPriorityResponse, cap(_ch))
	for _i := range _ch {
		var _r PathArgumentsPriorityResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
PathArgumentsPriority tests the priority of path arguments in functions.
*/
func (_c *Client) PathArgumentsPriority(ctx context.Context, foo string) (echo string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/path-arguments-priority/{foo}`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`foo`: foo,
	})
	_in := PathArgumentsPriorityIn{
		foo,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out PathArgumentsPriorityOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	echo = _out.Echo
	return
}

// WhatTimeIsItIn are the input arguments of WhatTimeIsIt.
type WhatTimeIsItIn struct {
}

// WhatTimeIsItOut are the return values of WhatTimeIsIt.
type WhatTimeIsItOut struct {
	T time.Time `json:"t"`
}

// WhatTimeIsItResponse is the response to WhatTimeIsIt.
type WhatTimeIsItResponse struct {
	data WhatTimeIsItOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *WhatTimeIsItResponse) Get() (t time.Time, err error) {
	t = _out.data.T
	err = _out.err
	return
}

/*
WhatTimeIsIt tests shifting the clock.
*/
func (_c *MulticastClient) WhatTimeIsIt(ctx context.Context) <-chan *WhatTimeIsItResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/what-time-is-it`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
	})
	_in := WhatTimeIsItIn{
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *WhatTimeIsItResponse, cap(_ch))
	for _i := range _ch {
		var _r WhatTimeIsItResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
WhatTimeIsIt tests shifting the clock.
*/
func (_c *Client) WhatTimeIsIt(ctx context.Context) (t time.Time, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/what-time-is-it`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
	})
	_in := WhatTimeIsItIn{
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out WhatTimeIsItOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	t = _out.T
	return
}

// OnDiscoveredIn are the input arguments of OnDiscovered.
type OnDiscoveredIn struct {
	P XYCoord `json:"p"`
	N int `json:"n"`
}

// OnDiscoveredOut are the return values of OnDiscovered.
type OnDiscoveredOut struct {
	Q XYCoord `json:"q"`
	M int `json:"m"`
}

// OnDiscoveredResponse is the response to OnDiscovered.
type OnDiscoveredResponse struct {
	data OnDiscoveredOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *OnDiscoveredResponse) Get() (q XYCoord, m int, err error) {
	q = _out.data.Q
	m = _out.data.M
	err = _out.err
	return
}

/*
OnDiscovered tests firing events.
*/
func (_c *MulticastTrigger) OnDiscovered(ctx context.Context, p XYCoord, n int) <-chan *OnDiscoveredResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:417/on-discovered`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`p`: p,
		`n`: n,
	})
	_in := OnDiscoveredIn{
		p,
		n,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *OnDiscoveredResponse, cap(_ch))
	for _i := range _ch {
		var _r OnDiscoveredResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
OnDiscovered tests firing events.
*/
func (_c *Hook) OnDiscovered(handler func(ctx context.Context, p XYCoord, n int) (q XYCoord, m int, err error)) error {
	doOnDiscovered := func(w http.ResponseWriter, r *http.Request) error {
		var i OnDiscoveredIn
		var o OnDiscoveredOut
		err := httpx.ParseRequestData(r, &i)
		if err != nil {
			return errors.Trace(err)
		}
		o.Q, o.M, err = handler(
			r.Context(),
			i.P,
			i.N,
		)
		if err != nil {
			return err // No trace
		}
		w.Header().Set("Content-Type", "application/json")
		encoder := json.NewEncoder(w)
		err = encoder.Encode(o)
		if err != nil {
			return errors.Trace(err)
		}
		return nil
	}
	path := httpx.JoinHostAndPath(_c.host, `:417/on-discovered`)
	if handler == nil {
		return _c.svc.Unsubscribe(`POST`, path)
	}
	return _c.svc.Subscribe(`POST`, path, doOnDiscovered)
}
