/*
Copyright (c) 2023-2024 Microbus LLC and various contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Microbus. DO NOT EDIT.

package tester

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/andybalholm/cascadia"
	"github.com/microbus-io/fabric/application"
	"github.com/microbus-io/fabric/connector"
	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/frame"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/rand"
	"github.com/microbus-io/fabric/utils"
	"github.com/microbus-io/testarossa"
	"golang.org/x/net/html"

	"github.com/microbus-io/fabric/codegen/tester/testerapi"
)

var (
	_ bytes.Buffer
	_ context.Context
	_ fmt.Stringer
	_ io.Reader
	_ *http.Request
	_ os.File
	_ time.Time
	_ strings.Builder
	_ cascadia.Sel
	_ *connector.Connector
	_ *errors.TracedError
	_ frame.Frame
	_ *httpx.BodyReader
	_ pub.Option
	_ rand.Void
	_ utils.SyncMap[string, string]
	_ testarossa.TestingT
	_ *html.Node
	_ *testerapi.Client
)

var (
	// App manages the lifecycle of the microservices used in the test
	App *application.Application
	// Svc is the codegen.test microservice being tested
	Svc *Service
)

func TestMain(m *testing.M) {
	var code int

	// Initialize the application
	err := func() error {
		var err error
		App = application.NewTesting()
		Svc = NewService()
		err = Initialize()
		if err != nil {
			return err
		}
		err = App.Startup()
		if err != nil {
			return err
		}
		return nil
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
		code = 19
	}

	// Run the tests
	if err == nil {
		code = m.Run()
	}

	// Terminate the app
	err = func() error {
		var err error
		var lastErr error
		err = App.Shutdown()
		if err != nil {
			lastErr = err
		}
		err = Terminate()
		if err != nil {
			lastErr = err
		}
		return lastErr
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
	}

	os.Exit(code)
}

// Context creates a new context for a test.
func Context() context.Context {
	return frame.ContextWithFrame(context.Background())
}

// StringCutTestCase assists in asserting against the results of executing StringCut.
type StringCutTestCase struct {
	_t *testing.T
	_dur time.Duration
	before string
	after string
	found bool
	err error
}

// Expect asserts no error and exact return values.
func (_tc *StringCutTestCase) Expect(before string, after string, found bool) *StringCutTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, before, _tc.before)
		testarossa.Equal(_tc._t, after, _tc.after)
		testarossa.Equal(_tc._t, found, _tc.found)
	}
	return _tc
}

// Error asserts an error.
func (tc *StringCutTestCase) Error(errContains string) *StringCutTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *StringCutTestCase) ErrorCode(statusCode int) *StringCutTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *StringCutTestCase) NoError() *StringCutTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *StringCutTestCase) CompletedIn(threshold time.Duration) *StringCutTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *StringCutTestCase) Assert(asserter func(t *testing.T, before string, after string, found bool, err error)) *StringCutTestCase {
	asserter(tc._t, tc.before, tc.after, tc.found, tc.err)
	return tc
}

// Get returns the result of executing StringCut.
func (tc *StringCutTestCase) Get() (before string, after string, found bool, err error) {
	return tc.before, tc.after, tc.found, tc.err
}

// StringCut executes the function and returns a corresponding test case.
func StringCut(t *testing.T, ctx context.Context, s string, sep string) *StringCutTestCase {
	tc := &StringCutTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.before, tc.after, tc.found, tc.err = Svc.StringCut(ctx, s, sep)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// PointDistanceTestCase assists in asserting against the results of executing PointDistance.
type PointDistanceTestCase struct {
	_t *testing.T
	_dur time.Duration
	d float64
	err error
}

// Expect asserts no error and exact return values.
func (_tc *PointDistanceTestCase) Expect(d float64) *PointDistanceTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, d, _tc.d)
	}
	return _tc
}

// Error asserts an error.
func (tc *PointDistanceTestCase) Error(errContains string) *PointDistanceTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *PointDistanceTestCase) ErrorCode(statusCode int) *PointDistanceTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *PointDistanceTestCase) NoError() *PointDistanceTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *PointDistanceTestCase) CompletedIn(threshold time.Duration) *PointDistanceTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *PointDistanceTestCase) Assert(asserter func(t *testing.T, d float64, err error)) *PointDistanceTestCase {
	asserter(tc._t, tc.d, tc.err)
	return tc
}

// Get returns the result of executing PointDistance.
func (tc *PointDistanceTestCase) Get() (d float64, err error) {
	return tc.d, tc.err
}

// PointDistance executes the function and returns a corresponding test case.
func PointDistance(t *testing.T, ctx context.Context, p1 testerapi.XYCoord, p2 *testerapi.XYCoord) *PointDistanceTestCase {
	tc := &PointDistanceTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.d, tc.err = Svc.PointDistance(ctx, p1, p2)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// ShiftPointTestCase assists in asserting against the results of executing ShiftPoint.
type ShiftPointTestCase struct {
	_t *testing.T
	_dur time.Duration
	shifted *testerapi.XYCoord
	err error
}

// Expect asserts no error and exact return values.
func (_tc *ShiftPointTestCase) Expect(shifted *testerapi.XYCoord) *ShiftPointTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, shifted, _tc.shifted)
	}
	return _tc
}

// Error asserts an error.
func (tc *ShiftPointTestCase) Error(errContains string) *ShiftPointTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *ShiftPointTestCase) ErrorCode(statusCode int) *ShiftPointTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *ShiftPointTestCase) NoError() *ShiftPointTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *ShiftPointTestCase) CompletedIn(threshold time.Duration) *ShiftPointTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *ShiftPointTestCase) Assert(asserter func(t *testing.T, shifted *testerapi.XYCoord, err error)) *ShiftPointTestCase {
	asserter(tc._t, tc.shifted, tc.err)
	return tc
}

// Get returns the result of executing ShiftPoint.
func (tc *ShiftPointTestCase) Get() (shifted *testerapi.XYCoord, err error) {
	return tc.shifted, tc.err
}

// ShiftPoint executes the function and returns a corresponding test case.
func ShiftPoint(t *testing.T, ctx context.Context, p *testerapi.XYCoord, x float64, y float64) *ShiftPointTestCase {
	tc := &ShiftPointTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.shifted, tc.err = Svc.ShiftPoint(ctx, p, x, y)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// LinesIntersectionTestCase assists in asserting against the results of executing LinesIntersection.
type LinesIntersectionTestCase struct {
	_t *testing.T
	_dur time.Duration
	b bool
	err error
}

// Expect asserts no error and exact return values.
func (_tc *LinesIntersectionTestCase) Expect(b bool) *LinesIntersectionTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, b, _tc.b)
	}
	return _tc
}

// Error asserts an error.
func (tc *LinesIntersectionTestCase) Error(errContains string) *LinesIntersectionTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *LinesIntersectionTestCase) ErrorCode(statusCode int) *LinesIntersectionTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *LinesIntersectionTestCase) NoError() *LinesIntersectionTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *LinesIntersectionTestCase) CompletedIn(threshold time.Duration) *LinesIntersectionTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *LinesIntersectionTestCase) Assert(asserter func(t *testing.T, b bool, err error)) *LinesIntersectionTestCase {
	asserter(tc._t, tc.b, tc.err)
	return tc
}

// Get returns the result of executing LinesIntersection.
func (tc *LinesIntersectionTestCase) Get() (b bool, err error) {
	return tc.b, tc.err
}

// LinesIntersection executes the function and returns a corresponding test case.
func LinesIntersection(t *testing.T, ctx context.Context, l1 testerapi.XYLine, l2 *testerapi.XYLine) *LinesIntersectionTestCase {
	tc := &LinesIntersectionTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.b, tc.err = Svc.LinesIntersection(ctx, l1, l2)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// SubArrayRangeTestCase assists in asserting against the results of executing SubArrayRange.
type SubArrayRangeTestCase struct {
	_t *testing.T
	_dur time.Duration
	httpResponseBody []int
	httpStatusCode int
	err error
}

// Expect asserts no error and exact return values.
func (_tc *SubArrayRangeTestCase) Expect(httpResponseBody []int, httpStatusCode int) *SubArrayRangeTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, httpResponseBody, _tc.httpResponseBody)
		testarossa.Equal(_tc._t, httpStatusCode, _tc.httpStatusCode)
	}
	return _tc
}

// Error asserts an error.
func (tc *SubArrayRangeTestCase) Error(errContains string) *SubArrayRangeTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *SubArrayRangeTestCase) ErrorCode(statusCode int) *SubArrayRangeTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *SubArrayRangeTestCase) NoError() *SubArrayRangeTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *SubArrayRangeTestCase) CompletedIn(threshold time.Duration) *SubArrayRangeTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *SubArrayRangeTestCase) Assert(asserter func(t *testing.T, httpResponseBody []int, httpStatusCode int, err error)) *SubArrayRangeTestCase {
	asserter(tc._t, tc.httpResponseBody, tc.httpStatusCode, tc.err)
	return tc
}

// Get returns the result of executing SubArrayRange.
func (tc *SubArrayRangeTestCase) Get() (httpResponseBody []int, httpStatusCode int, err error) {
	return tc.httpResponseBody, tc.httpStatusCode, tc.err
}

// SubArrayRange executes the function and returns a corresponding test case.
func SubArrayRange(t *testing.T, ctx context.Context, httpRequestBody []int, min int, max int) *SubArrayRangeTestCase {
	tc := &SubArrayRangeTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.httpResponseBody, tc.httpStatusCode, tc.err = Svc.SubArrayRange(ctx, httpRequestBody, min, max)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// SumTwoIntegersTestCase assists in asserting against the results of executing SumTwoIntegers.
type SumTwoIntegersTestCase struct {
	_t *testing.T
	_dur time.Duration
	sum int
	httpStatusCode int
	err error
}

// Expect asserts no error and exact return values.
func (_tc *SumTwoIntegersTestCase) Expect(sum int, httpStatusCode int) *SumTwoIntegersTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, sum, _tc.sum)
		testarossa.Equal(_tc._t, httpStatusCode, _tc.httpStatusCode)
	}
	return _tc
}

// Error asserts an error.
func (tc *SumTwoIntegersTestCase) Error(errContains string) *SumTwoIntegersTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *SumTwoIntegersTestCase) ErrorCode(statusCode int) *SumTwoIntegersTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *SumTwoIntegersTestCase) NoError() *SumTwoIntegersTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *SumTwoIntegersTestCase) CompletedIn(threshold time.Duration) *SumTwoIntegersTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *SumTwoIntegersTestCase) Assert(asserter func(t *testing.T, sum int, httpStatusCode int, err error)) *SumTwoIntegersTestCase {
	asserter(tc._t, tc.sum, tc.httpStatusCode, tc.err)
	return tc
}

// Get returns the result of executing SumTwoIntegers.
func (tc *SumTwoIntegersTestCase) Get() (sum int, httpStatusCode int, err error) {
	return tc.sum, tc.httpStatusCode, tc.err
}

// SumTwoIntegers executes the function and returns a corresponding test case.
func SumTwoIntegers(t *testing.T, ctx context.Context, x int, y int) *SumTwoIntegersTestCase {
	tc := &SumTwoIntegersTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.sum, tc.httpStatusCode, tc.err = Svc.SumTwoIntegers(ctx, x, y)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// FunctionPathArgumentsTestCase assists in asserting against the results of executing FunctionPathArguments.
type FunctionPathArgumentsTestCase struct {
	_t *testing.T
	_dur time.Duration
	joined string
	err error
}

// Expect asserts no error and exact return values.
func (_tc *FunctionPathArgumentsTestCase) Expect(joined string) *FunctionPathArgumentsTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, joined, _tc.joined)
	}
	return _tc
}

// Error asserts an error.
func (tc *FunctionPathArgumentsTestCase) Error(errContains string) *FunctionPathArgumentsTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *FunctionPathArgumentsTestCase) ErrorCode(statusCode int) *FunctionPathArgumentsTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *FunctionPathArgumentsTestCase) NoError() *FunctionPathArgumentsTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *FunctionPathArgumentsTestCase) CompletedIn(threshold time.Duration) *FunctionPathArgumentsTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *FunctionPathArgumentsTestCase) Assert(asserter func(t *testing.T, joined string, err error)) *FunctionPathArgumentsTestCase {
	asserter(tc._t, tc.joined, tc.err)
	return tc
}

// Get returns the result of executing FunctionPathArguments.
func (tc *FunctionPathArgumentsTestCase) Get() (joined string, err error) {
	return tc.joined, tc.err
}

// FunctionPathArguments executes the function and returns a corresponding test case.
func FunctionPathArguments(t *testing.T, ctx context.Context, named string, path2 string, suffix string) *FunctionPathArgumentsTestCase {
	tc := &FunctionPathArgumentsTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.joined, tc.err = Svc.FunctionPathArguments(ctx, named, path2, suffix)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// NonStringPathArgumentsTestCase assists in asserting against the results of executing NonStringPathArguments.
type NonStringPathArgumentsTestCase struct {
	_t *testing.T
	_dur time.Duration
	joined string
	err error
}

// Expect asserts no error and exact return values.
func (_tc *NonStringPathArgumentsTestCase) Expect(joined string) *NonStringPathArgumentsTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, joined, _tc.joined)
	}
	return _tc
}

// Error asserts an error.
func (tc *NonStringPathArgumentsTestCase) Error(errContains string) *NonStringPathArgumentsTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *NonStringPathArgumentsTestCase) ErrorCode(statusCode int) *NonStringPathArgumentsTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *NonStringPathArgumentsTestCase) NoError() *NonStringPathArgumentsTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *NonStringPathArgumentsTestCase) CompletedIn(threshold time.Duration) *NonStringPathArgumentsTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *NonStringPathArgumentsTestCase) Assert(asserter func(t *testing.T, joined string, err error)) *NonStringPathArgumentsTestCase {
	asserter(tc._t, tc.joined, tc.err)
	return tc
}

// Get returns the result of executing NonStringPathArguments.
func (tc *NonStringPathArgumentsTestCase) Get() (joined string, err error) {
	return tc.joined, tc.err
}

// NonStringPathArguments executes the function and returns a corresponding test case.
func NonStringPathArguments(t *testing.T, ctx context.Context, named int, path2 bool, suffix float64) *NonStringPathArgumentsTestCase {
	tc := &NonStringPathArgumentsTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.joined, tc.err = Svc.NonStringPathArguments(ctx, named, path2, suffix)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// UnnamedFunctionPathArgumentsTestCase assists in asserting against the results of executing UnnamedFunctionPathArguments.
type UnnamedFunctionPathArgumentsTestCase struct {
	_t *testing.T
	_dur time.Duration
	joined string
	err error
}

// Expect asserts no error and exact return values.
func (_tc *UnnamedFunctionPathArgumentsTestCase) Expect(joined string) *UnnamedFunctionPathArgumentsTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, joined, _tc.joined)
	}
	return _tc
}

// Error asserts an error.
func (tc *UnnamedFunctionPathArgumentsTestCase) Error(errContains string) *UnnamedFunctionPathArgumentsTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *UnnamedFunctionPathArgumentsTestCase) ErrorCode(statusCode int) *UnnamedFunctionPathArgumentsTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *UnnamedFunctionPathArgumentsTestCase) NoError() *UnnamedFunctionPathArgumentsTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *UnnamedFunctionPathArgumentsTestCase) CompletedIn(threshold time.Duration) *UnnamedFunctionPathArgumentsTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *UnnamedFunctionPathArgumentsTestCase) Assert(asserter func(t *testing.T, joined string, err error)) *UnnamedFunctionPathArgumentsTestCase {
	asserter(tc._t, tc.joined, tc.err)
	return tc
}

// Get returns the result of executing UnnamedFunctionPathArguments.
func (tc *UnnamedFunctionPathArgumentsTestCase) Get() (joined string, err error) {
	return tc.joined, tc.err
}

// UnnamedFunctionPathArguments executes the function and returns a corresponding test case.
func UnnamedFunctionPathArguments(t *testing.T, ctx context.Context, path1 string, path2 string, path3 string) *UnnamedFunctionPathArgumentsTestCase {
	tc := &UnnamedFunctionPathArgumentsTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.joined, tc.err = Svc.UnnamedFunctionPathArguments(ctx, path1, path2, path3)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// PathArgumentsPriorityTestCase assists in asserting against the results of executing PathArgumentsPriority.
type PathArgumentsPriorityTestCase struct {
	_t *testing.T
	_dur time.Duration
	echo string
	err error
}

// Expect asserts no error and exact return values.
func (_tc *PathArgumentsPriorityTestCase) Expect(echo string) *PathArgumentsPriorityTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, echo, _tc.echo)
	}
	return _tc
}

// Error asserts an error.
func (tc *PathArgumentsPriorityTestCase) Error(errContains string) *PathArgumentsPriorityTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *PathArgumentsPriorityTestCase) ErrorCode(statusCode int) *PathArgumentsPriorityTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *PathArgumentsPriorityTestCase) NoError() *PathArgumentsPriorityTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *PathArgumentsPriorityTestCase) CompletedIn(threshold time.Duration) *PathArgumentsPriorityTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *PathArgumentsPriorityTestCase) Assert(asserter func(t *testing.T, echo string, err error)) *PathArgumentsPriorityTestCase {
	asserter(tc._t, tc.echo, tc.err)
	return tc
}

// Get returns the result of executing PathArgumentsPriority.
func (tc *PathArgumentsPriorityTestCase) Get() (echo string, err error) {
	return tc.echo, tc.err
}

// PathArgumentsPriority executes the function and returns a corresponding test case.
func PathArgumentsPriority(t *testing.T, ctx context.Context, foo string) *PathArgumentsPriorityTestCase {
	tc := &PathArgumentsPriorityTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.echo, tc.err = Svc.PathArgumentsPriority(ctx, foo)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// WhatTimeIsItTestCase assists in asserting against the results of executing WhatTimeIsIt.
type WhatTimeIsItTestCase struct {
	_t *testing.T
	_dur time.Duration
	t time.Time
	err error
}

// Expect asserts no error and exact return values.
func (_tc *WhatTimeIsItTestCase) Expect(t time.Time) *WhatTimeIsItTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.True(_tc._t, t.Equal(_tc.t), "Expected %v, actual %v", t, _tc.t)
	}
	return _tc
}

// Error asserts an error.
func (tc *WhatTimeIsItTestCase) Error(errContains string) *WhatTimeIsItTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *WhatTimeIsItTestCase) ErrorCode(statusCode int) *WhatTimeIsItTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *WhatTimeIsItTestCase) NoError() *WhatTimeIsItTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *WhatTimeIsItTestCase) CompletedIn(threshold time.Duration) *WhatTimeIsItTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *WhatTimeIsItTestCase) Assert(asserter func(testingT *testing.T, t time.Time, err error)) *WhatTimeIsItTestCase {
	asserter(tc._t, tc.t, tc.err)
	return tc
}

// Get returns the result of executing WhatTimeIsIt.
func (tc *WhatTimeIsItTestCase) Get() (t time.Time, err error) {
	return tc.t, tc.err
}

// WhatTimeIsIt executes the function and returns a corresponding test case.
func WhatTimeIsIt(testingT *testing.T, ctx context.Context) *WhatTimeIsItTestCase {
	tc := &WhatTimeIsItTestCase{_t: testingT}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.t, tc.err = Svc.WhatTimeIsIt(ctx)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// OnDiscoveredSinkTestCase assists in asserting against the results of executing OnDiscoveredSink.
type OnDiscoveredSinkTestCase struct {
	_t *testing.T
	_dur time.Duration
	q testerapi.XYCoord
	m int
	err error
}

// Expect asserts no error and exact return values.
func (_tc *OnDiscoveredSinkTestCase) Expect(q testerapi.XYCoord, m int) *OnDiscoveredSinkTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, q, _tc.q)
		testarossa.Equal(_tc._t, m, _tc.m)
	}
	return _tc
}

// Error asserts an error.
func (tc *OnDiscoveredSinkTestCase) Error(errContains string) *OnDiscoveredSinkTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *OnDiscoveredSinkTestCase) ErrorCode(statusCode int) *OnDiscoveredSinkTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *OnDiscoveredSinkTestCase) NoError() *OnDiscoveredSinkTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *OnDiscoveredSinkTestCase) CompletedIn(threshold time.Duration) *OnDiscoveredSinkTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *OnDiscoveredSinkTestCase) Assert(asserter func(t *testing.T, q testerapi.XYCoord, m int, err error)) *OnDiscoveredSinkTestCase {
	asserter(tc._t, tc.q, tc.m, tc.err)
	return tc
}

// Get returns the result of executing OnDiscoveredSink.
func (tc *OnDiscoveredSinkTestCase) Get() (q testerapi.XYCoord, m int, err error) {
	return tc.q, tc.m, tc.err
}

// OnDiscoveredSink executes the function and returns a corresponding test case.
func OnDiscoveredSink(t *testing.T, ctx context.Context, p testerapi.XYCoord, n int) *OnDiscoveredSinkTestCase {
	tc := &OnDiscoveredSinkTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.q, tc.m, tc.err = Svc.OnDiscoveredSink(ctx, p, n)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// OnDiscoveredTestCase assists in asserting the sink of OnDiscovered.
type OnDiscoveredTestCase struct {
	_t *testing.T
    _asserters []func()
	_done chan bool
	_triggered bool
	ctx context.Context
	p testerapi.XYCoord
	n int
	q testerapi.XYCoord
	m int
	err error
}

// Expect asserts that the event sink was triggered with an exact match of its input arguments.
func (_tc *OnDiscoveredTestCase) Expect(p testerapi.XYCoord, n int) *OnDiscoveredTestCase {
	_tc._asserters = append(_tc._asserters, func() {
		if testarossa.True(_tc._t, _tc._triggered, "Event sink was not triggered") {
			testarossa.Equal(_tc._t, p, _tc.p)
			testarossa.Equal(_tc._t, n, _tc.n)
		}
	})
	return _tc
}

// Assert asserts that the event sink was triggered with a custom function to assert its input arguments.
func (_tc *OnDiscoveredTestCase) Assert(asserter func(t *testing.T, ctx context.Context, p testerapi.XYCoord, n int)) *OnDiscoveredTestCase {
	_tc._asserters = append(_tc._asserters, func() {
		if testarossa.True(_tc._t, _tc._triggered, "Event sink was not triggered") {
			asserter(_tc._t, _tc.ctx, _tc.p, _tc.n)
		}
	})
	return _tc
}

// Return sets the values to return from the event sink to the event source.
func (_tc *OnDiscoveredTestCase) Return(q testerapi.XYCoord, m int, err error) *OnDiscoveredTestCase {
	_tc.q = q
	_tc.m = m
	_tc.err = err
	return _tc
}

// Wait waits for the event sink to be triggered. It is necessary to wait for events that are triggered asynchronously.
func (_tc *OnDiscoveredTestCase) Wait() *OnDiscoveredTestCase {
	timeout := 20 * time.Second
	if deadline, ok := _tc._t.Deadline(); ok {
		timeout = time.Until(deadline)
	}
	timer := time.NewTimer(timeout)
	defer timer.Stop()
	select {
	case <-_tc._done:
	case <-timer.C:
		testarossa.True(_tc._t, false, "Timed out", "Event sink was not triggered")
	}
	return _tc
}

// OnDiscovered creates a run-once event sink and returns the corresponding test case.
func OnDiscovered(t *testing.T) *OnDiscoveredTestCase {
	_tc := &OnDiscoveredTestCase{
		_t: t,
		_done: make(chan bool),
	}
	con := connector.New("OnDiscovered." + rand.AlphaNum64(12))
	testerapi.NewHook(con).OnDiscovered(func(ctx context.Context, p testerapi.XYCoord, n int) (q testerapi.XYCoord, m int, err error) {
		testerapi.NewHook(con).OnDiscovered(nil)
		_tc.ctx = ctx
		_tc.p = p
		_tc.n = n
		_tc._triggered = true
		close(_tc._done)
		for _, asserter := range _tc._asserters {
			asserter()
		}
		_tc._asserters = nil
		return _tc.q, _tc.m, _tc.err
	})
	App.AddAndStartup(con)
	_tc._t.Cleanup(func() {
		con.Shutdown()
		App.Remove(con)
		for _, asserter := range _tc._asserters {
			asserter()
		}
	})
	return _tc
}

// EchoTestCase assists in asserting against the results of executing Echo.
type EchoTestCase struct {
	t *testing.T
	dur time.Duration
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *EchoTestCase) StatusOK() *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *EchoTestCase) StatusCode(statusCode int) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response body contains the string or byte array value.
func (tc *EchoTestCase) BodyContains(value any) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.True(tc.t, bytes.Contains(body, v), "%v does not contain %v", body, v)
		case string:
			testarossa.Contains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.Contains(tc.t, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response body does not contain the string or byte array value.
func (tc *EchoTestCase) BodyNotContains(value any) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.False(tc.t, bytes.Contains(body, v), "%v contains %v", body, v)
		case string:
			testarossa.NotContains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.NotContains(tc.t, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains the value.
func (tc *EchoTestCase) HeaderContains(headerName string, value string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *EchoTestCase) HeaderNotContains(headerName string, value string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotContains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderEqual asserts no error and that the named header matches the value.
func (tc *EchoTestCase) HeaderEqual(headerName string, value string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderNotEqual asserts no error and that the named header does not matche the value.
func (tc *EchoTestCase) HeaderNotEqual(headerName string, value string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *EchoTestCase) HeaderExists(headerName string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s does not exist", headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header does not exists.
func (tc *EchoTestCase) HeaderNotExists(headerName string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s exists", headerName)
	}
	return tc
}

// ContentType asserts no error and that the Content-Type header matches the expected value.
func (tc *EchoTestCase) ContentType(expected string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, expected, tc.res.Header.Get("Content-Type"))
	}
	return tc
}

/*
TagExists asserts no error and that the at least one tag matches the CSS selector query.

Examples:

	TagExists(`TR > TD > A.expandable[href]`)
	TagExists(`DIV#main_panel`)
	TagExists(`TR TD INPUT[name="x"]`)
*/
func (tc *EchoTestCase) TagExists(cssSelectorQuery string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.NotEqual(tc.t, 0, len(matches), "Found no tags matching %s", cssSelectorQuery)
	}
	return tc
}

/*
TagNotExists asserts no error and that the no tag matches the CSS selector query.

Example:

	TagNotExists(`TR > TD > A.expandable[href]`)
	TagNotExists(`DIV#main_panel`)
	TagNotExists(`TR TD INPUT[name="x"]`)
*/
func (tc *EchoTestCase) TagNotExists(cssSelectorQuery string) *EchoTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.Equal(tc.t, 0, len(matches), "Found %d tag(s) matching %s", len(matches), cssSelectorQuery)
	}
	return tc
}

/*
TagEqual asserts no error and that the at least one of the tags matching the CSS selector query
either contains the exact text itself or has a descendant that does.

Example:

	TagEqual("TR > TD > A.expandable[href]", "Expand")
	TagEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *EchoTestCase) TagEqual(cssSelectorQuery string, value string) *EchoTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagContains asserts no error and that the at least one of the tags matching the CSS selector query
either contains the text itself or has a descendant that does.

Example:

	TagContains("TR > TD > A.expandable[href]", "Expand")
	TagContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *EchoTestCase) TagContains(cssSelectorQuery string, value string) *EchoTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotEqual asserts no error and that there is no tag matching the CSS selector that
either contains the exact text itself or has a descendant that does.

Example:

	TagNotEqual("TR > TD > A[href]", "Harry Potter")
	TagNotEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *EchoTestCase) TagNotEqual(cssSelectorQuery string, value string) *EchoTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotContains asserts no error and that there is no tag matching the CSS selector that
either contains the text itself or has a descendant that does.

Example:

	TagNotContains("TR > TD > A[href]", "Harry Potter")
	TagNotContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *EchoTestCase) TagNotContains(cssSelectorQuery string, value string) *EchoTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

// Error asserts an error.
func (tc *EchoTestCase) Error(errContains string) *EchoTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *EchoTestCase) ErrorCode(statusCode int) *EchoTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *EchoTestCase) NoError() *EchoTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *EchoTestCase) CompletedIn(threshold time.Duration) *EchoTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *EchoTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *EchoTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Echo.
func (tc *EchoTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
Echo_Get performs a GET request to the Echo endpoint.

Echo tests a typical web handler.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Echo_Get(t *testing.T, ctx context.Context, url string) *EchoTestCase {
	tc := &EchoTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(testerapi.URLOfEcho, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest("GET", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Echo(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Echo_Post performs a POST request to the Echo endpoint.

Echo tests a typical web handler.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func Echo_Post(t *testing.T, ctx context.Context, url string, contentType string, body any) *EchoTestCase {
	tc := &EchoTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(testerapi.URLOfEcho, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest("POST", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	err = httpx.SetRequestBody(r, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Echo(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Echo tests a typical web handler.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Echo(t *testing.T, r *http.Request) *EchoTestCase {
	tc := &EchoTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	url, err := httpx.ResolveURL(testerapi.URLOfEcho, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = httpx.ParseURL(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	for k, vv := range frame.Of(r.Context()).Header() {
		r.Header[k] = vv
	}
	ctx := frame.ContextWithFrameOf(r.Context(), r.Header)
	r = r.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Echo(w, r)
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// MultiValueHeadersTestCase assists in asserting against the results of executing MultiValueHeaders.
type MultiValueHeadersTestCase struct {
	t *testing.T
	dur time.Duration
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *MultiValueHeadersTestCase) StatusOK() *MultiValueHeadersTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *MultiValueHeadersTestCase) StatusCode(statusCode int) *MultiValueHeadersTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response body contains the string or byte array value.
func (tc *MultiValueHeadersTestCase) BodyContains(value any) *MultiValueHeadersTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.True(tc.t, bytes.Contains(body, v), "%v does not contain %v", body, v)
		case string:
			testarossa.Contains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.Contains(tc.t, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response body does not contain the string or byte array value.
func (tc *MultiValueHeadersTestCase) BodyNotContains(value any) *MultiValueHeadersTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.False(tc.t, bytes.Contains(body, v), "%v contains %v", body, v)
		case string:
			testarossa.NotContains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.NotContains(tc.t, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains the value.
func (tc *MultiValueHeadersTestCase) HeaderContains(headerName string, value string) *MultiValueHeadersTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *MultiValueHeadersTestCase) HeaderNotContains(headerName string, value string) *MultiValueHeadersTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotContains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderEqual asserts no error and that the named header matches the value.
func (tc *MultiValueHeadersTestCase) HeaderEqual(headerName string, value string) *MultiValueHeadersTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderNotEqual asserts no error and that the named header does not matche the value.
func (tc *MultiValueHeadersTestCase) HeaderNotEqual(headerName string, value string) *MultiValueHeadersTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *MultiValueHeadersTestCase) HeaderExists(headerName string) *MultiValueHeadersTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s does not exist", headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header does not exists.
func (tc *MultiValueHeadersTestCase) HeaderNotExists(headerName string) *MultiValueHeadersTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s exists", headerName)
	}
	return tc
}

// ContentType asserts no error and that the Content-Type header matches the expected value.
func (tc *MultiValueHeadersTestCase) ContentType(expected string) *MultiValueHeadersTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, expected, tc.res.Header.Get("Content-Type"))
	}
	return tc
}

/*
TagExists asserts no error and that the at least one tag matches the CSS selector query.

Examples:

	TagExists(`TR > TD > A.expandable[href]`)
	TagExists(`DIV#main_panel`)
	TagExists(`TR TD INPUT[name="x"]`)
*/
func (tc *MultiValueHeadersTestCase) TagExists(cssSelectorQuery string) *MultiValueHeadersTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.NotEqual(tc.t, 0, len(matches), "Found no tags matching %s", cssSelectorQuery)
	}
	return tc
}

/*
TagNotExists asserts no error and that the no tag matches the CSS selector query.

Example:

	TagNotExists(`TR > TD > A.expandable[href]`)
	TagNotExists(`DIV#main_panel`)
	TagNotExists(`TR TD INPUT[name="x"]`)
*/
func (tc *MultiValueHeadersTestCase) TagNotExists(cssSelectorQuery string) *MultiValueHeadersTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.Equal(tc.t, 0, len(matches), "Found %d tag(s) matching %s", len(matches), cssSelectorQuery)
	}
	return tc
}

/*
TagEqual asserts no error and that the at least one of the tags matching the CSS selector query
either contains the exact text itself or has a descendant that does.

Example:

	TagEqual("TR > TD > A.expandable[href]", "Expand")
	TagEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *MultiValueHeadersTestCase) TagEqual(cssSelectorQuery string, value string) *MultiValueHeadersTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagContains asserts no error and that the at least one of the tags matching the CSS selector query
either contains the text itself or has a descendant that does.

Example:

	TagContains("TR > TD > A.expandable[href]", "Expand")
	TagContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *MultiValueHeadersTestCase) TagContains(cssSelectorQuery string, value string) *MultiValueHeadersTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotEqual asserts no error and that there is no tag matching the CSS selector that
either contains the exact text itself or has a descendant that does.

Example:

	TagNotEqual("TR > TD > A[href]", "Harry Potter")
	TagNotEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *MultiValueHeadersTestCase) TagNotEqual(cssSelectorQuery string, value string) *MultiValueHeadersTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotContains asserts no error and that there is no tag matching the CSS selector that
either contains the text itself or has a descendant that does.

Example:

	TagNotContains("TR > TD > A[href]", "Harry Potter")
	TagNotContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *MultiValueHeadersTestCase) TagNotContains(cssSelectorQuery string, value string) *MultiValueHeadersTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

// Error asserts an error.
func (tc *MultiValueHeadersTestCase) Error(errContains string) *MultiValueHeadersTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *MultiValueHeadersTestCase) ErrorCode(statusCode int) *MultiValueHeadersTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *MultiValueHeadersTestCase) NoError() *MultiValueHeadersTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *MultiValueHeadersTestCase) CompletedIn(threshold time.Duration) *MultiValueHeadersTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *MultiValueHeadersTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *MultiValueHeadersTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing MultiValueHeaders.
func (tc *MultiValueHeadersTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
MultiValueHeaders_Get performs a GET request to the MultiValueHeaders endpoint.

MultiValueHeaders tests a passing in and returning headers with multiple values.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func MultiValueHeaders_Get(t *testing.T, ctx context.Context, url string) *MultiValueHeadersTestCase {
	tc := &MultiValueHeadersTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(testerapi.URLOfMultiValueHeaders, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest("GET", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.MultiValueHeaders(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
MultiValueHeaders_Post performs a POST request to the MultiValueHeaders endpoint.

MultiValueHeaders tests a passing in and returning headers with multiple values.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func MultiValueHeaders_Post(t *testing.T, ctx context.Context, url string, contentType string, body any) *MultiValueHeadersTestCase {
	tc := &MultiValueHeadersTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(testerapi.URLOfMultiValueHeaders, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest("POST", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	err = httpx.SetRequestBody(r, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.MultiValueHeaders(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
MultiValueHeaders tests a passing in and returning headers with multiple values.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func MultiValueHeaders(t *testing.T, r *http.Request) *MultiValueHeadersTestCase {
	tc := &MultiValueHeadersTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	url, err := httpx.ResolveURL(testerapi.URLOfMultiValueHeaders, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = httpx.ParseURL(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	for k, vv := range frame.Of(r.Context()).Header() {
		r.Header[k] = vv
	}
	ctx := frame.ContextWithFrameOf(r.Context(), r.Header)
	r = r.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.MultiValueHeaders(w, r)
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// WebPathArgumentsTestCase assists in asserting against the results of executing WebPathArguments.
type WebPathArgumentsTestCase struct {
	t *testing.T
	dur time.Duration
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *WebPathArgumentsTestCase) StatusOK() *WebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *WebPathArgumentsTestCase) StatusCode(statusCode int) *WebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response body contains the string or byte array value.
func (tc *WebPathArgumentsTestCase) BodyContains(value any) *WebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.True(tc.t, bytes.Contains(body, v), "%v does not contain %v", body, v)
		case string:
			testarossa.Contains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.Contains(tc.t, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response body does not contain the string or byte array value.
func (tc *WebPathArgumentsTestCase) BodyNotContains(value any) *WebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.False(tc.t, bytes.Contains(body, v), "%v contains %v", body, v)
		case string:
			testarossa.NotContains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.NotContains(tc.t, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains the value.
func (tc *WebPathArgumentsTestCase) HeaderContains(headerName string, value string) *WebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *WebPathArgumentsTestCase) HeaderNotContains(headerName string, value string) *WebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotContains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderEqual asserts no error and that the named header matches the value.
func (tc *WebPathArgumentsTestCase) HeaderEqual(headerName string, value string) *WebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderNotEqual asserts no error and that the named header does not matche the value.
func (tc *WebPathArgumentsTestCase) HeaderNotEqual(headerName string, value string) *WebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *WebPathArgumentsTestCase) HeaderExists(headerName string) *WebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s does not exist", headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header does not exists.
func (tc *WebPathArgumentsTestCase) HeaderNotExists(headerName string) *WebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s exists", headerName)
	}
	return tc
}

// ContentType asserts no error and that the Content-Type header matches the expected value.
func (tc *WebPathArgumentsTestCase) ContentType(expected string) *WebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, expected, tc.res.Header.Get("Content-Type"))
	}
	return tc
}

/*
TagExists asserts no error and that the at least one tag matches the CSS selector query.

Examples:

	TagExists(`TR > TD > A.expandable[href]`)
	TagExists(`DIV#main_panel`)
	TagExists(`TR TD INPUT[name="x"]`)
*/
func (tc *WebPathArgumentsTestCase) TagExists(cssSelectorQuery string) *WebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.NotEqual(tc.t, 0, len(matches), "Found no tags matching %s", cssSelectorQuery)
	}
	return tc
}

/*
TagNotExists asserts no error and that the no tag matches the CSS selector query.

Example:

	TagNotExists(`TR > TD > A.expandable[href]`)
	TagNotExists(`DIV#main_panel`)
	TagNotExists(`TR TD INPUT[name="x"]`)
*/
func (tc *WebPathArgumentsTestCase) TagNotExists(cssSelectorQuery string) *WebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.Equal(tc.t, 0, len(matches), "Found %d tag(s) matching %s", len(matches), cssSelectorQuery)
	}
	return tc
}

/*
TagEqual asserts no error and that the at least one of the tags matching the CSS selector query
either contains the exact text itself or has a descendant that does.

Example:

	TagEqual("TR > TD > A.expandable[href]", "Expand")
	TagEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *WebPathArgumentsTestCase) TagEqual(cssSelectorQuery string, value string) *WebPathArgumentsTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagContains asserts no error and that the at least one of the tags matching the CSS selector query
either contains the text itself or has a descendant that does.

Example:

	TagContains("TR > TD > A.expandable[href]", "Expand")
	TagContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *WebPathArgumentsTestCase) TagContains(cssSelectorQuery string, value string) *WebPathArgumentsTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotEqual asserts no error and that there is no tag matching the CSS selector that
either contains the exact text itself or has a descendant that does.

Example:

	TagNotEqual("TR > TD > A[href]", "Harry Potter")
	TagNotEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *WebPathArgumentsTestCase) TagNotEqual(cssSelectorQuery string, value string) *WebPathArgumentsTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotContains asserts no error and that there is no tag matching the CSS selector that
either contains the text itself or has a descendant that does.

Example:

	TagNotContains("TR > TD > A[href]", "Harry Potter")
	TagNotContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *WebPathArgumentsTestCase) TagNotContains(cssSelectorQuery string, value string) *WebPathArgumentsTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

// Error asserts an error.
func (tc *WebPathArgumentsTestCase) Error(errContains string) *WebPathArgumentsTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *WebPathArgumentsTestCase) ErrorCode(statusCode int) *WebPathArgumentsTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *WebPathArgumentsTestCase) NoError() *WebPathArgumentsTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *WebPathArgumentsTestCase) CompletedIn(threshold time.Duration) *WebPathArgumentsTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *WebPathArgumentsTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *WebPathArgumentsTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing WebPathArguments.
func (tc *WebPathArgumentsTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
WebPathArguments_Get performs a GET request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func WebPathArguments_Get(t *testing.T, ctx context.Context, url string) *WebPathArgumentsTestCase {
	tc := &WebPathArgumentsTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(testerapi.URLOfWebPathArguments, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest("GET", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.WebPathArguments(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
WebPathArguments_Post performs a POST request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func WebPathArguments_Post(t *testing.T, ctx context.Context, url string, contentType string, body any) *WebPathArgumentsTestCase {
	tc := &WebPathArgumentsTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(testerapi.URLOfWebPathArguments, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest("POST", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	err = httpx.SetRequestBody(r, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.WebPathArguments(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
WebPathArguments tests path arguments in web handlers.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func WebPathArguments(t *testing.T, r *http.Request) *WebPathArgumentsTestCase {
	tc := &WebPathArgumentsTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	url, err := httpx.ResolveURL(testerapi.URLOfWebPathArguments, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = httpx.ParseURL(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	for k, vv := range frame.Of(r.Context()).Header() {
		r.Header[k] = vv
	}
	ctx := frame.ContextWithFrameOf(r.Context(), r.Header)
	r = r.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.WebPathArguments(w, r)
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// UnnamedWebPathArgumentsTestCase assists in asserting against the results of executing UnnamedWebPathArguments.
type UnnamedWebPathArgumentsTestCase struct {
	t *testing.T
	dur time.Duration
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *UnnamedWebPathArgumentsTestCase) StatusOK() *UnnamedWebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *UnnamedWebPathArgumentsTestCase) StatusCode(statusCode int) *UnnamedWebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response body contains the string or byte array value.
func (tc *UnnamedWebPathArgumentsTestCase) BodyContains(value any) *UnnamedWebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.True(tc.t, bytes.Contains(body, v), "%v does not contain %v", body, v)
		case string:
			testarossa.Contains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.Contains(tc.t, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response body does not contain the string or byte array value.
func (tc *UnnamedWebPathArgumentsTestCase) BodyNotContains(value any) *UnnamedWebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.False(tc.t, bytes.Contains(body, v), "%v contains %v", body, v)
		case string:
			testarossa.NotContains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.NotContains(tc.t, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains the value.
func (tc *UnnamedWebPathArgumentsTestCase) HeaderContains(headerName string, value string) *UnnamedWebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *UnnamedWebPathArgumentsTestCase) HeaderNotContains(headerName string, value string) *UnnamedWebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotContains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderEqual asserts no error and that the named header matches the value.
func (tc *UnnamedWebPathArgumentsTestCase) HeaderEqual(headerName string, value string) *UnnamedWebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderNotEqual asserts no error and that the named header does not matche the value.
func (tc *UnnamedWebPathArgumentsTestCase) HeaderNotEqual(headerName string, value string) *UnnamedWebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *UnnamedWebPathArgumentsTestCase) HeaderExists(headerName string) *UnnamedWebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s does not exist", headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header does not exists.
func (tc *UnnamedWebPathArgumentsTestCase) HeaderNotExists(headerName string) *UnnamedWebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s exists", headerName)
	}
	return tc
}

// ContentType asserts no error and that the Content-Type header matches the expected value.
func (tc *UnnamedWebPathArgumentsTestCase) ContentType(expected string) *UnnamedWebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, expected, tc.res.Header.Get("Content-Type"))
	}
	return tc
}

/*
TagExists asserts no error and that the at least one tag matches the CSS selector query.

Examples:

	TagExists(`TR > TD > A.expandable[href]`)
	TagExists(`DIV#main_panel`)
	TagExists(`TR TD INPUT[name="x"]`)
*/
func (tc *UnnamedWebPathArgumentsTestCase) TagExists(cssSelectorQuery string) *UnnamedWebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.NotEqual(tc.t, 0, len(matches), "Found no tags matching %s", cssSelectorQuery)
	}
	return tc
}

/*
TagNotExists asserts no error and that the no tag matches the CSS selector query.

Example:

	TagNotExists(`TR > TD > A.expandable[href]`)
	TagNotExists(`DIV#main_panel`)
	TagNotExists(`TR TD INPUT[name="x"]`)
*/
func (tc *UnnamedWebPathArgumentsTestCase) TagNotExists(cssSelectorQuery string) *UnnamedWebPathArgumentsTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.Equal(tc.t, 0, len(matches), "Found %d tag(s) matching %s", len(matches), cssSelectorQuery)
	}
	return tc
}

/*
TagEqual asserts no error and that the at least one of the tags matching the CSS selector query
either contains the exact text itself or has a descendant that does.

Example:

	TagEqual("TR > TD > A.expandable[href]", "Expand")
	TagEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *UnnamedWebPathArgumentsTestCase) TagEqual(cssSelectorQuery string, value string) *UnnamedWebPathArgumentsTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagContains asserts no error and that the at least one of the tags matching the CSS selector query
either contains the text itself or has a descendant that does.

Example:

	TagContains("TR > TD > A.expandable[href]", "Expand")
	TagContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *UnnamedWebPathArgumentsTestCase) TagContains(cssSelectorQuery string, value string) *UnnamedWebPathArgumentsTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotEqual asserts no error and that there is no tag matching the CSS selector that
either contains the exact text itself or has a descendant that does.

Example:

	TagNotEqual("TR > TD > A[href]", "Harry Potter")
	TagNotEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *UnnamedWebPathArgumentsTestCase) TagNotEqual(cssSelectorQuery string, value string) *UnnamedWebPathArgumentsTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotContains asserts no error and that there is no tag matching the CSS selector that
either contains the text itself or has a descendant that does.

Example:

	TagNotContains("TR > TD > A[href]", "Harry Potter")
	TagNotContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *UnnamedWebPathArgumentsTestCase) TagNotContains(cssSelectorQuery string, value string) *UnnamedWebPathArgumentsTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

// Error asserts an error.
func (tc *UnnamedWebPathArgumentsTestCase) Error(errContains string) *UnnamedWebPathArgumentsTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *UnnamedWebPathArgumentsTestCase) ErrorCode(statusCode int) *UnnamedWebPathArgumentsTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *UnnamedWebPathArgumentsTestCase) NoError() *UnnamedWebPathArgumentsTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *UnnamedWebPathArgumentsTestCase) CompletedIn(threshold time.Duration) *UnnamedWebPathArgumentsTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *UnnamedWebPathArgumentsTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *UnnamedWebPathArgumentsTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing UnnamedWebPathArguments.
func (tc *UnnamedWebPathArgumentsTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}
/*
UnnamedWebPathArguments tests path arguments that are not named.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func UnnamedWebPathArguments(t *testing.T, ctx context.Context, url string) *UnnamedWebPathArgumentsTestCase {
	tc := &UnnamedWebPathArgumentsTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(testerapi.URLOfUnnamedWebPathArguments, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.UnnamedWebPathArguments(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
UnnamedWebPathArguments_Do performs a customized request to the UnnamedWebPathArguments endpoint.

UnnamedWebPathArguments tests path arguments that are not named.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func UnnamedWebPathArguments_Do(t *testing.T, r *http.Request) *UnnamedWebPathArgumentsTestCase {
	tc := &UnnamedWebPathArgumentsTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	if r.Method != `GET` {
		tc.err = errors.Newc(http.StatusNotFound, "")
		return tc
	}
	url, err := httpx.ResolveURL(testerapi.URLOfUnnamedWebPathArguments, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = httpx.ParseURL(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	for k, vv := range frame.Of(r.Context()).Header() {
		r.Header[k] = vv
	}
	ctx := frame.ContextWithFrameOf(r.Context(), r.Header)
	r = r.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.UnnamedWebPathArguments(w, r)
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// DirectoryServerTestCase assists in asserting against the results of executing DirectoryServer.
type DirectoryServerTestCase struct {
	t *testing.T
	dur time.Duration
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *DirectoryServerTestCase) StatusOK() *DirectoryServerTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *DirectoryServerTestCase) StatusCode(statusCode int) *DirectoryServerTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response body contains the string or byte array value.
func (tc *DirectoryServerTestCase) BodyContains(value any) *DirectoryServerTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.True(tc.t, bytes.Contains(body, v), "%v does not contain %v", body, v)
		case string:
			testarossa.Contains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.Contains(tc.t, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response body does not contain the string or byte array value.
func (tc *DirectoryServerTestCase) BodyNotContains(value any) *DirectoryServerTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.False(tc.t, bytes.Contains(body, v), "%v contains %v", body, v)
		case string:
			testarossa.NotContains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.NotContains(tc.t, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains the value.
func (tc *DirectoryServerTestCase) HeaderContains(headerName string, value string) *DirectoryServerTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *DirectoryServerTestCase) HeaderNotContains(headerName string, value string) *DirectoryServerTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotContains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderEqual asserts no error and that the named header matches the value.
func (tc *DirectoryServerTestCase) HeaderEqual(headerName string, value string) *DirectoryServerTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderNotEqual asserts no error and that the named header does not matche the value.
func (tc *DirectoryServerTestCase) HeaderNotEqual(headerName string, value string) *DirectoryServerTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *DirectoryServerTestCase) HeaderExists(headerName string) *DirectoryServerTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s does not exist", headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header does not exists.
func (tc *DirectoryServerTestCase) HeaderNotExists(headerName string) *DirectoryServerTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s exists", headerName)
	}
	return tc
}

// ContentType asserts no error and that the Content-Type header matches the expected value.
func (tc *DirectoryServerTestCase) ContentType(expected string) *DirectoryServerTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, expected, tc.res.Header.Get("Content-Type"))
	}
	return tc
}

/*
TagExists asserts no error and that the at least one tag matches the CSS selector query.

Examples:

	TagExists(`TR > TD > A.expandable[href]`)
	TagExists(`DIV#main_panel`)
	TagExists(`TR TD INPUT[name="x"]`)
*/
func (tc *DirectoryServerTestCase) TagExists(cssSelectorQuery string) *DirectoryServerTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.NotEqual(tc.t, 0, len(matches), "Found no tags matching %s", cssSelectorQuery)
	}
	return tc
}

/*
TagNotExists asserts no error and that the no tag matches the CSS selector query.

Example:

	TagNotExists(`TR > TD > A.expandable[href]`)
	TagNotExists(`DIV#main_panel`)
	TagNotExists(`TR TD INPUT[name="x"]`)
*/
func (tc *DirectoryServerTestCase) TagNotExists(cssSelectorQuery string) *DirectoryServerTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.Equal(tc.t, 0, len(matches), "Found %d tag(s) matching %s", len(matches), cssSelectorQuery)
	}
	return tc
}

/*
TagEqual asserts no error and that the at least one of the tags matching the CSS selector query
either contains the exact text itself or has a descendant that does.

Example:

	TagEqual("TR > TD > A.expandable[href]", "Expand")
	TagEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *DirectoryServerTestCase) TagEqual(cssSelectorQuery string, value string) *DirectoryServerTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagContains asserts no error and that the at least one of the tags matching the CSS selector query
either contains the text itself or has a descendant that does.

Example:

	TagContains("TR > TD > A.expandable[href]", "Expand")
	TagContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *DirectoryServerTestCase) TagContains(cssSelectorQuery string, value string) *DirectoryServerTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotEqual asserts no error and that there is no tag matching the CSS selector that
either contains the exact text itself or has a descendant that does.

Example:

	TagNotEqual("TR > TD > A[href]", "Harry Potter")
	TagNotEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *DirectoryServerTestCase) TagNotEqual(cssSelectorQuery string, value string) *DirectoryServerTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotContains asserts no error and that there is no tag matching the CSS selector that
either contains the text itself or has a descendant that does.

Example:

	TagNotContains("TR > TD > A[href]", "Harry Potter")
	TagNotContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *DirectoryServerTestCase) TagNotContains(cssSelectorQuery string, value string) *DirectoryServerTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

// Error asserts an error.
func (tc *DirectoryServerTestCase) Error(errContains string) *DirectoryServerTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *DirectoryServerTestCase) ErrorCode(statusCode int) *DirectoryServerTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *DirectoryServerTestCase) NoError() *DirectoryServerTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *DirectoryServerTestCase) CompletedIn(threshold time.Duration) *DirectoryServerTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *DirectoryServerTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *DirectoryServerTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing DirectoryServer.
func (tc *DirectoryServerTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}
/*
DirectoryServer tests service resources given a greedy path argument.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func DirectoryServer(t *testing.T, ctx context.Context, url string) *DirectoryServerTestCase {
	tc := &DirectoryServerTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(testerapi.URLOfDirectoryServer, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.DirectoryServer(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
DirectoryServer_Do performs a customized request to the DirectoryServer endpoint.

DirectoryServer tests service resources given a greedy path argument.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func DirectoryServer_Do(t *testing.T, r *http.Request) *DirectoryServerTestCase {
	tc := &DirectoryServerTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	if r.Method != `GET` {
		tc.err = errors.Newc(http.StatusNotFound, "")
		return tc
	}
	url, err := httpx.ResolveURL(testerapi.URLOfDirectoryServer, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = httpx.ParseURL(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	for k, vv := range frame.Of(r.Context()).Header() {
		r.Header[k] = vv
	}
	ctx := frame.ContextWithFrameOf(r.Context(), r.Header)
	r = r.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.DirectoryServer(w, r)
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// HelloTestCase assists in asserting against the results of executing Hello.
type HelloTestCase struct {
	t *testing.T
	dur time.Duration
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *HelloTestCase) StatusOK() *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *HelloTestCase) StatusCode(statusCode int) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response body contains the string or byte array value.
func (tc *HelloTestCase) BodyContains(value any) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.True(tc.t, bytes.Contains(body, v), "%v does not contain %v", body, v)
		case string:
			testarossa.Contains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.Contains(tc.t, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response body does not contain the string or byte array value.
func (tc *HelloTestCase) BodyNotContains(value any) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		switch v := value.(type) {
		case []byte:
			testarossa.False(tc.t, bytes.Contains(body, v), "%v contains %v", body, v)
		case string:
			testarossa.NotContains(tc.t, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			testarossa.NotContains(tc.t, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains the value.
func (tc *HelloTestCase) HeaderContains(headerName string, value string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *HelloTestCase) HeaderNotContains(headerName string, value string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotContains(tc.t, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderEqual asserts no error and that the named header matches the value.
func (tc *HelloTestCase) HeaderEqual(headerName string, value string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderNotEqual asserts no error and that the named header does not matche the value.
func (tc *HelloTestCase) HeaderNotEqual(headerName string, value string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, value, tc.res.Header.Get(headerName))
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *HelloTestCase) HeaderExists(headerName string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.NotEqual(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s does not exist", headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header does not exists.
func (tc *HelloTestCase) HeaderNotExists(headerName string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, 0, len(tc.res.Header.Values(headerName)), "Header %s exists", headerName)
	}
	return tc
}

// ContentType asserts no error and that the Content-Type header matches the expected value.
func (tc *HelloTestCase) ContentType(expected string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		testarossa.Equal(tc.t, expected, tc.res.Header.Get("Content-Type"))
	}
	return tc
}

/*
TagExists asserts no error and that the at least one tag matches the CSS selector query.

Examples:

	TagExists(`TR > TD > A.expandable[href]`)
	TagExists(`DIV#main_panel`)
	TagExists(`TR TD INPUT[name="x"]`)
*/
func (tc *HelloTestCase) TagExists(cssSelectorQuery string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.NotEqual(tc.t, 0, len(matches), "Found no tags matching %s", cssSelectorQuery)
	}
	return tc
}

/*
TagNotExists asserts no error and that the no tag matches the CSS selector query.

Example:

	TagNotExists(`TR > TD > A.expandable[href]`)
	TagNotExists(`DIV#main_panel`)
	TagNotExists(`TR TD INPUT[name="x"]`)
*/
func (tc *HelloTestCase) TagNotExists(cssSelectorQuery string) *HelloTestCase {
	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		testarossa.Equal(tc.t, 0, len(matches), "Found %d tag(s) matching %s", len(matches), cssSelectorQuery)
	}
	return tc
}

/*
TagEqual asserts no error and that the at least one of the tags matching the CSS selector query
either contains the exact text itself or has a descendant that does.

Example:

	TagEqual("TR > TD > A.expandable[href]", "Expand")
	TagEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *HelloTestCase) TagEqual(cssSelectorQuery string, value string) *HelloTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagContains asserts no error and that the at least one of the tags matching the CSS selector query
either contains the text itself or has a descendant that does.

Example:

	TagContains("TR > TD > A.expandable[href]", "Expand")
	TagContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *HelloTestCase) TagContains(cssSelectorQuery string, value string) *HelloTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if !testarossa.NotEqual(tc.t, 0, len(matches), "Selector %s does not match any tags", cssSelectorQuery) {
			return tc
		}
		if value == "" {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.True(tc.t, found, "No tag matching %s contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotEqual asserts no error and that there is no tag matching the CSS selector that
either contains the exact text itself or has a descendant that does.

Example:

	TagNotEqual("TR > TD > A[href]", "Harry Potter")
	TagNotEqual("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *HelloTestCase) TagNotEqual(cssSelectorQuery string, value string) *HelloTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if x.Data == value || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

/*
TagNotContains asserts no error and that there is no tag matching the CSS selector that
either contains the text itself or has a descendant that does.

Example:

	TagNotContains("TR > TD > A[href]", "Harry Potter")
	TagNotContains("DIV#main_panel > SELECT > OPTION", "Red")
*/
func (tc *HelloTestCase) TagNotContains(cssSelectorQuery string, value string) *HelloTestCase {
	var textMatches func(n *html.Node) bool
	textMatches = func(n *html.Node) bool {
		for x := n.FirstChild; x != nil; x = x.NextSibling {
			if strings.Contains(x.Data, value) || textMatches(x) {
				return true
			}
		}
		return false
	}

	if testarossa.NoError(tc.t, tc.err) {
		selector, err := cascadia.Compile(cssSelectorQuery)
		if !testarossa.NoError(tc.t, err, "Invalid selector %s", cssSelectorQuery) {
			return tc
		}
		var body []byte
		if br, ok := tc.res.Body.(*httpx.BodyReader); ok {
			body = br.Bytes()
		} else {
			var err error
			body, err = io.ReadAll(tc.res.Body)
			if !testarossa.NoError(tc.t, err, "Failed to read body") {
				return tc
			}
			tc.res.Body = io.NopCloser(bytes.NewReader(body))
		}
		doc, err := html.Parse(bytes.NewReader(body))
		if !testarossa.NoError(tc.t, err, "Failed to parse HTML") {
			return tc
		}
		matches := selector.MatchAll(doc)
		if len(matches) == 0 {
			return tc
		}
		if !testarossa.NotEqual(tc.t, "", value, "Found tag matching %s", cssSelectorQuery) {
			return tc
		}
		found := false
		for _, match := range matches {
			if textMatches(match) {
				found = true
				break
			}
		}
		testarossa.False(tc.t, found, "Found tag matching %s that contains %s", cssSelectorQuery, value)
	}
	return tc
}

// Error asserts an error.
func (tc *HelloTestCase) Error(errContains string) *HelloTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *HelloTestCase) ErrorCode(statusCode int) *HelloTestCase {
	if testarossa.Error(tc.t, tc.err) {
		testarossa.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *HelloTestCase) NoError() *HelloTestCase {
	testarossa.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *HelloTestCase) CompletedIn(threshold time.Duration) *HelloTestCase {
	testarossa.True(tc.t, tc.dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *HelloTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *HelloTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Hello.
func (tc *HelloTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
Hello_Get performs a GET request to the Hello endpoint.

Hello prints hello in the language best matching the request's Accept-Language header.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Hello_Get(t *testing.T, ctx context.Context, url string) *HelloTestCase {
	tc := &HelloTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(testerapi.URLOfHello, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest("GET", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Hello(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Hello_Post performs a POST request to the Hello endpoint.

Hello prints hello in the language best matching the request's Accept-Language header.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func Hello_Post(t *testing.T, ctx context.Context, url string, contentType string, body any) *HelloTestCase {
	tc := &HelloTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(testerapi.URLOfHello, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest("POST", url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = frame.CloneContext(ctx)
	r = r.WithContext(ctx)
	r.Header = frame.Of(ctx).Header()
	err = httpx.SetRequestBody(r, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Hello(w, r)
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Hello prints hello in the language best matching the request's Accept-Language header.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Hello(t *testing.T, r *http.Request) *HelloTestCase {
	tc := &HelloTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	url, err := httpx.ResolveURL(testerapi.URLOfHello, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	url, err = httpx.FillPathArguments(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = httpx.ParseURL(url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	for k, vv := range frame.Of(r.Context()).Header() {
		r.Header[k] = vv
	}
	ctx := frame.ContextWithFrameOf(r.Context(), r.Header)
	r = r.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Hello(w, r)
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}
